<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>A. RECORD AND PLAY SOUNDFILES</title>
  </head>
  <body><h1>A. RECORD AND PLAY SOUNDFILES</h1><h2>Playing Soundfiles From Disk - diskin2<sup data-id="b1e0d781-9120-4d7a-bd17-0762cdd78cad" class="endnote">1</sup> </h2>
<p>The simplest way of playing a sound file from Csound is to use
the <a href="http://www.csounds.com/manual/html/diskin2.html">diskin2</a> opcode.
This opcode reads audio directly from the hard drive location where
it is stored, i.e. it does not pre-load the sound file at
initialisation time. This method of sound file playback is
therefore good for playing back very long, or parts of very long,
sound files. It is perhaps less well suited to playing back sound
files where dense polyphony, multiple iterations and rapid random
access to the file is required. In these situations reading from a
function table or buffer is preferable.</p>
<p><a href="http://www.csounds.com/manual/html/diskin2.html"><span>diskin2</span></a>
<span>has additional parameters for speed of playback, and
interpolation</span><span>.</span></p>
<p>   <em><strong>EXAMPLE
06A01_Play_soundfile.csd</strong></em>  </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ; activate real-time audio output
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr      =       44100
ksmps   =       32
nchnls  =       1       

  instr 1 ; play audio from disk
kSpeed  init     1           ; playback speed
iSkip   init     0           ; inskip into file (in seconds)
iLoop   init     0           ; looping switch (0=off 1=on)
; read audio from disk using diskin2 opcode
a1      diskin2  "loop.wav", kSpeed, iSkip, iLoop
        out      a1          ; send audio to outputs
  endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 6
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p> </p>
<h2>Writing Audio to Disk</h2>
<p>The traditional method of rendering Csound's audio to disk is to
specify a sound file as the audio destination in the Csound command
or under &lt;CsOptions&gt;. In fact before real-time performance
became a possibility this was the only way in which Csound was
used. With this method, all audio that is piped to the output using
<em>out, outs</em> etc. will be written to this file. The number of
channels that the file will contain will be determined by the
number of channels specified in the orchestra header using
'nchnls'. The disadvantage of this method is that we cannot
simultaneously listen to the audio in real-time.</p>
<p>   <em><strong>EXAMPLE
06A02_Write_soundfile.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
; audio output destination is given as a sound file (wav format specified)
; this method is for deferred time performance,
; simultaneous real-time audio will not be possible
-oWriteToDisk1.wav -W
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr     =  44100
ksmps  =  32
nchnls =  1     
0dbfs  =  1

giSine  ftgen  0, 0, 4096, 10, 1             ; a sine wave

  instr 1 ; a simple tone generator
aEnv    expon    0.2, p3, 0.001              ; a percussive envelope
aSig    poscil   aEnv, cpsmidinn(p4), giSine ; audio oscillator
        out      aSig                        ; send audio to output
  endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; two chords
i 1   0 5 60
i 1 0.1 5 65
i 1 0.2 5 67
i 1 0.3 5 71

i 1   3 5 65
i 1 3.1 5 67
i 1 3.2 5 73
i 1 3.3 5 78
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p> </p>
<h2>Writing Audio to Disk with Simultaneous Real-time Audio Output
- fout and monitor</h2>
<p>Recording audio output to disk whilst simultaneously monitoring
in real-time is best achieved through combining the opcodes
<a href="http://www.csounds.com/manual/html/monitor.html">monitor</a>
and <a href="http://www.csounds.com/manual/html/fout.html">fout</a>. 'monitor'
can be used to create an audio signal that consists of a mix of all
audio output from all instruments. This audio signal can then be
rendered to a sound file on disk using 'fout'. 'monitor' can read
multi-channel outputs but its number of outputs should correspond
to the number of channels defined in the header using 'nchnls'. In
this example it is read just in mono. 'fout' can write audio in a
number of formats and bit depths and it can also write
multi-channel sound files. </p>
<p>   <em><strong>EXAMPLE
06A03_Write_RT.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ; activate real-time audio output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr      =       44100
ksmps   =       32
nchnls  =       1       
0dbfs   =       1

giSine  ftgen  0, 0, 4096, 10, 1 ; a sine wave
gaSig   init   0; set initial value for global audio variable (silence)

  instr 1 ; a simple tone generator
aEnv    expon    0.2, p3, 0.001              ; percussive amplitude envelope
aSig    poscil   aEnv, cpsmidinn(p4), giSine ; audio oscillator
        out      aSig
  endin

  instr 2 ; write to a file (always on in order to record everything)
aSig    monitor                              ; read audio from output bus
        fout     "WriteToDisk2.wav",4,aSig   ; write audio to file (16bit mono)
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; activate recording instrument to encapsulate the entire performance
i 2 0 8.3

; two chords
i 1   0 5 60
i 1 0.1 5 65
i 1 0.2 5 67
i 1 0.3 5 71

i 1   3 5 65
i 1 3.1 5 67
i 1 3.2 5 73
i 1 3.3 5 78
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer</pre>
<p> </p>
<ol class="endnotes">
<li id="endnote-b1e0d781-9120-4d7a-bd17-0762cdd78cad">diskin2 is an improved version of diskin.
In Csound 6, both will use the same code, so it should make no
difference whether you use diskin or diskin2.</li></ol>
</body>
</html>
