D. FREQUENCY MODULATION
=======================

Basic Model {#basic-model style=""}
-----------

In FM synthesis, the frequency of one oscillator (called the carrier) is
modulated by the signal from another oscillator (called the modulator).
The output of the modulating oscillator is added to the frequency input
of the carrier oscillator.

::: {.group_img .image-layout-1image_1caption_bottom style="text-align: start;"}
::: {.image .bk-image-editor style="width: 450px; height: 530px;"}
![](static/fm_191009.png)
:::

::: {.caption_small style="width: 450px;"}
Basic Model of Frequency Modulation
:::
:::

::: {.group_img .image-layout-1image_1caption_bottom style="text-align: start;"}
::: {.caption_small}
\
:::
:::

The amplitude of the modulator determines the amount of modulation, or
the frequency deviation from the fundamental carrier frequency. The
frequency of the modulator determines how frequent the deviation will
occur in one second. The amplitude of the modulator determines the
amount of the deviation. An amplitude of 1 will alter the carrier
frequency by +-1 Hz, wheras an amplitude of 10 will alter the carrier
frequency by +-10 Hz. If the amplitude of the modulating signal is zero,
there is no modulation and the output from the carrier oscillator is
simply a sine wave with the frequency of the carrier. When modulation
occurs, the signal from the modulation oscillator, a sine wave with
frequency ModFreq, drives the frequency of the carrier oscillator both
above and below the carrier frequency CarFreq. If the modulator is
running in the sub-audio frequency range (below 20 Hz), the result of FM
is vibrato. When the modulator's frequency rises in the audio range, we
hear it as a change in the timbre of the carrier.

\

***EXAMPLE 04D01\_Frequency\_modulation.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr FM_vibr ;vibrato as an FM result when the modulator is in the sub-audio range
 kModFreq randomi 5, 10, 1
 kCarAmp linen 0.5, 0.1, p3, 0.5
 aModulator poscil 20, kModFreq 
 aCarrier poscil kCarAmp, 400 + aModulator 
 out aCarrier, aCarrier
endin

instr FM_timbr ;timbre change when the modulator’s frequency is in the audio range
 kModAmp linseg 0, p3/2, 212, p3/2, 50
 kModFreq line 25, p3, 300
 kCarAmp linen 0.5, 0.1, p3, 0.5
 aModulator poscil kModAmp, kModFreq
 aCarrier poscil kCarAmp, 400 + aModulator
 out aCarrier, aCarrier
endin

</CsInstruments>
<CsScore>
i "FM_vibr" 0 10
i "FM_timbr" 10 10
</CsScore>
</CsoundSynthesizer>
;example by marijana janevska
```

Carrier/Modulator Ratio
-----------------------

The position of the frequency components generated by FM depends on the
relationship of the carrier frequency to the modulating frequency
CarFreq/ModFreq. This is called the ratio. When CarFreq/ModFreq is a
simple integer ratio, such as 4:1 (as in the case of two signals at 400
and 100 Hz), FM generates harmonic spectra, that is sidebands that are
integer multiplies of the carrier and modulating frequencies. When
CarFreq/ModFreq is not a simple integer ratio, such as 8:2.1 (as in the
case of two signals at 800 and 210 Hz), FM generates inharmonic spectra
(noninteger multiplies of the carrier and modulator).

\

***EXAMPLE 04D02\_Ratio.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr Ratio
 kRatio = p4
 kCarFreq = 400
 kModFreq = kCarFreq/kRatio
 aModulator poscil 500, kModFreq
 aCarrier poscil 0.3, kCarFreq + aModulator
 aOut linen aCarrier, .1, p3, 1
 out aOut, aOut
endin

</CsInstruments>
<CsScore>
i 1 0 5 2
i . + . 2.1
</CsScore>
</CsoundSynthesizer>
;example written by marijana janevska
```

Index of Modulation
-------------------

FM of two sinusoids generates a series of sidebands around the carrier
frequency (CarFreq). Each sideband spreads out at a distance equal to a
multiple of the modulating amplitude (ModAmp).

::: {.group_img style="text-align: start;"}
::: {.image .bk-image-editor style="width: 656.512px; height: 312.575px;"}
![](static/fm_2pic.png)
:::
:::

The bandwidth of the FM spectrum (the number of sidebands) is controlled
by the index of modulation (**I)**. The Index is defined mathematically
according to the following relation:

\

 I = ModAmp/ModFreq

\

where ModAmp is the amount of frequency deviation (in Hz) from the
carrier frequency. Hence, ModAmp is a way of expressing the depth or
amount of modulation. The amplitude of each sideband depends on the
index of modulation. When there is no modulation, the index of
modulation is zero and all the signal power resides in the carrier
frequency. Increasing the value of the index causes the sidebands to
acquire more power at the expense of the power of the carrier frequency.
The wider the deviation, the more widely distributed is the power among
the sidebands and the greater the number of sidebands that have
significant amplitudes. The number of significant sideband pairs (those
that are more than 1/100 the amplitude of the carrier) is approximately
I+1. For certain values of the carrier and modulator frequencies and
Index, extreme sidebands reflect out of the upper and lower ends of the
spectrum, causing audible side effects. When the lower sidebands extend
below 0 Hz, they reflect back into the spectrum in 180 degree phase
inverted form. Negative frequency components add richness to the lower
frequency portion of the spectrum, but if negative components overlap
exactly with positive components, they can cancel each other. In simple
FM, both oscillators use sine waves as their source waveform, although
any waveform can be used. The FM can produce such rich spectra, that,
when one waveform with a large number of spectral components frequency
modulates another, the resulting sound can be so dense that it sounds
harsh and undefined. Aliasing can occur easily.

\

***EXAMPLE 04D03\_Index.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr Rising_index
 ModAmp = 400
 kIndex linseg 3, p3, 8
 kModFreq = kModAmp/kIndex 
 aModulator poscil kModAmp, kModFreq
 aCarrier poscil 0.3, 400 + aModulator
 aOut linen aCarrier, .1, p3, 1 
 out aOut, aOut
endin

</CsInstruments>
<CsScore>
i "Rising_index" 0 10
</CsScore>
</CsoundSynthesizer>
;example by marijana janevska and joachim heintz
```

Standard FM with Ratio and Index  {#standard-fm-with-ratio-and-index style=""}
---------------------------------

In the basic FM model three variables are given: the frequency of the
carrier (CarFreq or simply C), the frequency of the modulator (ModFreq
or simply M) and the amplitude of the modulator which results in the
frequency deviation (so ModAmp or D). By introducing the Ratio (C/M) and
the Index (D/M) as musically meaningful values, it makes sense to
transform the previous C, M and D input to C, R and I. C yields the base
(or perhaps better: middle) frequency of the sound, R yields the overall
characteristic of the timbre, I yields the emergence of the side bands.
The three musically meaningful input values can easily be transformed
into the basic model:

if R = C / M then M = C / R and

if I = D / M then D = I · M.

\

***EXAMPLE 04D04\_Standard.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-odac  -m128
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr Standard

//input
 iC = 400
 iR = p4 ;ratio
 iI = p5 ;index
 prints "Ration = %.3f, Index = %.3f\n", iR, iI

 //transform
 iM = iC / iR
 iD = iI * iM

 //apply to standard model
 aModulator poscil iD, iM
 aCarrier poscil 0.3, iC + aModulator
 aOut linen aCarrier, .1, p3, 1
 out aOut, aOut

endin

instr PlayMess
 
 kC randomi 300, 500, 1, 2, 400
 kR randomi 1, 2, 2, 3
 kI randomi 1, 5, randomi:k(3,10,1,3), 3
 
 //transform
 kM = kC / kR
 kD = kI * kM

 //apply to standard model
 aModulator poscil kD, kM
 aCarrier poscil ampdb(port:k(kI*5-30,.1)), kC + aModulator
 aOut linen aCarrier, .1, p3, p3/10
 out aOut, aOut

endin

</CsInstruments>
<CsScore>
//changing the ratio at constant index=3
i "Standard" 0 3 1 3
i . + . 1.41 .
i . + . 1.75 .
i . + . 2.07 .
s
//changing the index at constant ratio=3.3
i "Standard" 0 3 3.3 0
i . + . . 1
i . + . . 5
i . + . . 10
s
//let some nonsense happen
i "PlayMess" 0 30
</CsScore>
</CsoundSynthesizer>
;example by joachim heintz
```

  {#section style=""}

------------------------------------------------------------------------

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\

The John Chowning FM Model of a Trumpet
---------------------------------------

Composer and researcher Jown Chowning worked on the first digital
implementation of FM in the 1970\'s.

Using envelopes to control the *modulation index* and the overall
amplitude gives you the possibility to create evolving sounds with
enormous spectral variations. Chowning showed these possibilities in his
pieces, where he let the sounds transform. In the piece *Sabelithe* a
drum sound morphes over the time into a trumpet tone.

***EXAMPLE 04D05\_Trumpet\_FM.csd*** 

    <CsoundSynthesizer>
    <CsOptions>
    -o dac
    </CsOptions>
    <CsInstruments>
    sr = 48000
    ksmps = 32
    nchnls = 2
    0dbfs = 1

    instr 1  ; simple way to generate a trumpet-like sound
    kCarFreq = 440
    kModFreq = 440
    kIndex = 5
    kIndexM = 0
    kMaxDev = kIndex*kModFreq
    kMinDev = kIndexM * kModFreq
    kVarDev = kMaxDev-kMinDev
    aEnv expseg .001, 0.2, 1, p3-0.3, 1, 0.2, 0.001
    aModAmp = kMinDev+kVarDev*aEnv
    aModulator poscil aModAmp, kModFreq, 1
    aCarrier poscil 0.3*aEnv, kCarFreq+aModulator, 1
    outs aCarrier, aCarrier
    endin

    </CsInstruments>
    <CsScore>
    f 1 0 1024 10 1                 ;Sine wave for table 1
    i 1 0 2
    </CsScore>
    </CsoundSynthesizer>
    ; written by Alex Hofmann (Mar. 2011)

 

The following example uses the same instrument, with different settings
to generate a bell-like sound:

***EXAMPLE 04D06\_Bell\_FM.csd***

    <CsoundSynthesizer>
    <CsOptions>
    -o dac
    </CsOptions>
    <CsInstruments>
    sr = 48000
    ksmps = 32
    nchnls = 2
    0dbfs = 1

    instr 1  ; bell-like sound
    kCarFreq = 200  ; 200/280 = 5:7 -> inharmonic spectrum
    kModFreq = 280
    kIndex = 12
    kIndexM = 0
    kMaxDev = kIndex*kModFreq
    kMinDev = kIndexM * kModFreq
    kVarDev = kMaxDev-kMinDev
    aEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
    aModAmp = kMinDev+kVarDev*aEnv
    aModulator poscil aModAmp, kModFreq, 1
    aCarrier poscil 0.3*aEnv, kCarFreq+aModulator, 1
    outs aCarrier, aCarrier
    endin

    </CsInstruments>
    <CsScore>
    f 1 0 1024 10 1                 ;Sine wave for table 1
    i 1 0 9
    </CsScore>
    </CsoundSynthesizer>
    ; written by Alex Hofmann (Mar. 2011)

More Complex FM Algorithms
--------------------------

Combining more than two oscillators (operators) is called complex FM
synthesis. Operators can be connected in different combinations; often
4-6 operators are used. The carrier is always the last operator in the
row. Changing it\'s pitch shifts the whole sound. All other operators
are modulators, changing their pitch alters the sound-spectrum.

#### Two into One: M1+M2 -\> C

The principle here is, that (M1:C) and (M2:C) will be separate
modulations and later added together. 

***EXAMPLE 04D07\_Added\_FM.csd*** 

    <CsoundSynthesizer>
    <CsOptions>
    -o dac
    </CsOptions>
    <CsInstruments>
    sr = 48000
    ksmps = 32
    nchnls = 2
    0dbfs = 1

    instr 1
    aMod1 poscil 200, 700, 1
    aMod2 poscil 1800, 290, 1
    aSig poscil 0.3, 440+aMod1+aMod2, 1
    outs aSig, aSig
    endin


    </CsInstruments>
    <CsScore>
    f 1 0 1024 10 1                 ;Sine wave for table 1
    i 1 0 3
    </CsScore>
    </CsoundSynthesizer>
    ; written by Alex Hofmann (Mar. 2011)

#### In series: M1-\>M2-\>C

This is much more complicated to calculate and sound-timbre becomes
harder to predict, because M1:M2 produces a complex spectrum (W), which
then modulates the carrier (W:C).

***EXAMPLE 04D08\_Serial\_FM.csd*** 

    <CsoundSynthesizer>
    <CsOptions>
    -o dac
    </CsOptions>
    <CsInstruments>
    sr = 48000
    ksmps = 32
    nchnls = 2
    0dbfs = 1

    instr 1
    aMod1 poscil 200, 700, 1
    aMod2 poscil 1800, 290+aMod1, 1
    aSig poscil 0.3, 440+aMod2, 1
    outs aSig, aSig
    endin

    </CsInstruments>
    <CsScore>
    f 1 0 1024 10 1                 ;Sine wave for table 1
    i 1 0 3
    </CsScore>
    </CsoundSynthesizer>
    ; written by Alex Hofmann (Mar. 2011)

 

Phase Modulation - the Yamaha DX7 and Feedback FM
-------------------------------------------------

There is a strong relation between frequency modulation and phase
modulation, as both techniques influence the oscillator\'s pitch, and
the resulting timbre modifications are the same.

If you\'d like to build a feedbacking FM system, it will happen that the
self-modulation comes to a zero point, which stops the oscillator
forever. To avoid this, it is more practical to modulate the carriers
table-lookup phase, instead of its pitch.

Even the most famous FM-synthesizer Yamaha DX7 is based on the
phase-modulation (PM) technique, because this allows feedback. The DX7
provides 7 operators, and offers 32 routing combinations of these.
(http://yala.freeservers.com/t2synths.htm\#DX7)

To build a PM-synth in Csound *tablei* opcode needs to be used as
oscillator. In order to step through the f-table, a *phasor* will output
the necessary steps.

***EXAMPLE 04D09\_PhaseMod.csd*** 

    <CsoundSynthesizer>
    <CsOptions>
    -o dac
    </CsOptions>
    <CsInstruments>
    sr = 48000
    ksmps = 32
    nchnls = 2
    0dbfs = 1

    instr 1  ; simple PM-Synth
    kCarFreq = 200
    kModFreq = 280
    kModFactor = kCarFreq/kModFreq
    kIndex = 12/6.28   ;  12/2pi to convert from radians to norm. table index
    aEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
    aModulator poscil kIndex*aEnv, kModFreq, 1
    aPhase phasor kCarFreq
    aCarrier tablei aPhase+aModulator, 1, 1, 0, 1
    outs (aCarrier*aEnv), (aCarrier*aEnv)
    endin

    </CsInstruments>
    <CsScore>
    f 1 0 1024 10 1                 ;Sine wave for table 1
    i 1 0 9
    </CsScore>
    </CsoundSynthesizer>
    ; written by Alex Hofmann (Mar. 2011)

Let\'s use the possibilities of self-modulation (feedback-modulation) of
the oscillator. So in the following example, the oscillator is both
*modulator* and *carrier*. To control the amount of modulation, an
envelope scales the feedback.

***EXAMPLE 04D10\_Feedback\_modulation.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-o dac
</CsOptions>
<CsInstruments>
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1  ; feedback PM
kCarFreq = 200
kFeedbackAmountEnv linseg 0, 2, 0.2, 0.1, 0.3, 0.8, 0.2, 1.5, 0
aAmpEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
aPhase phasor kCarFreq
aCarrier init 0 ; init for feedback
aCarrier tablei aPhase+(aCarrier*kFeedbackAmountEnv), 1, 1, 0, 1
outs aCarrier*aAmpEnv, aCarrier*aAmpEnv
endin

</CsInstruments>
<CsScore>
f 1 0 1024 10 1                 ;Sine wave for table 1
i 1 0 9
</CsScore>
</CsoundSynthesizer>
; written by Alex Hofmann (Mar. 2011)
```

\

\

\

::: {.group_img style="text-align: start;"}
::: {.image .bk-image-editor style="width: 656.231px; height: 312.938px;"}
![](static/fm_2pic.png)
:::
:::

Multiple carriers (MC FM)
-------------------------

By multiple carrier frequency modulation, we mean an FM instrument in
which one oscillator simultaneously modulates two or more carrier
oscillators.

\

***EXAMPLE 04D15\_Multiple\_Carrier\_FM.csd***\

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1 ; FM with two carriers

aModulator poscil 100, 14
aCarrier1 poscil 0.3, 700 + aModulator
aCarrier2 poscil 0.1, 701 + aModulator
outs aCarrier1+aCarrier2, aCarrier1+aCarrier2
 
endin

</CsInstruments>
<CsScore>

i1 0 10

</CsScore>
</CsoundSynthesizer>
```

Multiple modulators (MM FM)
---------------------------

In multiple modulator frequency modulation, more than one oscillator
modulates a single carrier oscillator. Two basic configurations are
possible: parallel and series. In parallel MM FM, two sinewaves
simultaneously modulate a single carrier oscillator.

In series MM FM, the output of the first modulator is added to the
second modulator, which then is applied to the frequency input of the
carrier.

\

***EXAMPLE 04D16\_Multiple\_Modulator\_FM.csd***\

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
-odac -d
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1 ; parallel FM with two modulators

aModulator1 poscil 100, 80
aModulator2 poscil 20, 3
aCarrier poscil 0.3, 400 + aModulator1 + aModulator2
outs aCarrier, aCarrier

endin

instr 2 ; series FM with two modulators

aModulator2 poscil 100, 1/10
aModulator1 poscil 20, 3 + aModulator2
aCarrier poscil 0.3, 400 + aModulator1
outs aCarrier, aCarrier

endin

</CsInstruments>
<CsScore>

i1 0 80
;i2 0 80

</CsScore>
</CsoundSynthesizer>
```

When one carrier and one modulator is used, the FM synthesis can also be
implemented by using the foscil code. This opcode models a pair of
oscillators configured as a carrier and a modulator, producing a single
output signal from the carrier.

***EXAMPLE 04D17\_FM\_with\_Foscil.csd***

``` {style=""}
<CsoundSynthesizer>
<CsOptions>
</CsOptions>
<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine ftgen 0, 0, 8192, 10, 1

instr 1 

aCarMod foscil 0.3, 110, 1, 2, 5, giSine
outs aCarMod, aCarMod

endin

</CsInstruments>
<CsScore>

i1 0 99

</CsScore>
</CsoundSynthesizer>
```
