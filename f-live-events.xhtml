<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>F. LIVE EVENTS</title>
  </head>
  <body><h1>F. LIVE EVENTS</h1><p>The basic concept of Csound from the early days of the program
is still valid and useful because it is a musically
familiar one: you create a set of instruments and instruct
them to play at various times. These calls of instrument instances,
and their execution, are called "instrument events".</p>
<p>Whenever any Csound code is executed, it has to be compiled
first. Since Csound6, you can change the code of any running Csound
instance, and recompile it on the fly. There are basically two
opcodes for this "live coding": <a href="http://www.csounds.com/manual/html/compileorc.html">compileorc</a>
re-compiles any existing orc file, whereas <a href="http://www.csounds.com/manual/html/compilestr.html">compilestr</a>
compiles any string. At the end of this chapter, we will present
some simple examples for both methods, followed by a description
how to re-compile code on the fly in CsoundQt.</p>
<p>The scheme of instruments and events can be instigated in a
number of ways. In the classical approach you think of an
"orchestra" with a number of musicians playing from a "score", but
you can also trigger instruments using any kind of live input: from
MIDI, from OSC, from the command line, from a GUI (such as Csound's
FLTK widgets or CsoundQt's widgets), from the API (also used in
CsoundQt's Live Event Sheet). Or you can create a kind of "master
instrument", which is always on, and triggers other instruments
using opcodes designed for this task, perhaps under certain
conditions: if the live audio input from a singer has been detected
to have a base frequency greater than 1043 Hz, then start an
instrument which plays a soundfile of broken glass...</p>
<h2>Order of Execution Revisited</h2>
<p>Whatever you do in Csound with instrument events, you must bear
in mind the order of execution that has been explained in the first
chapter of this section about the <em>Initialization and
Performance Pass</em>: instruments are executed one by one, both in
the initialization pass and in each control cycle, and the order is
determined <strong>by the instrument number</strong>.</p>
<p>It is worth to have a closer look to what is happening exactly
in time if you trigger an instrument from inside another
instrument. The first example shows the result when instrument 2
triggers instrument 1 and instrument 3 <strong>at
init-time</strong>.</p>
<p>   <em><strong>EXAMPLE
03F01_OrderOfExc_event_i.csd</strong></em>  </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441

instr 1
kCycle timek
prints "Instrument 1 is here at initialization.\n"
printks "Instrument 1: kCycle = %d\n", 0, kCycle
endin

instr 2
kCycle timek
prints "  Instrument 2 is here at initialization.\n"
printks "  Instrument 2: kCycle = %d\n", 0, kCycle
event_i "i", 3, 0, .02
event_i "i", 1, 0, .02
endin

instr 3
kCycle timek
prints "    Instrument 3 is here at initialization.\n"
printks "    Instrument 3: kCycle = %d\n", 0, kCycle
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 2 0 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>This is the output:<br/>
<span>  Instrument 2 is here at initialization.<br/>
    Instrument 3 is here at initialization.<br/>
Instrument 1 is here at initialization.<br/>
Instrument 1: kCycle = 1<br/>
  Instrument 2: kCycle = 1<br/>
    Instrument 3: kCycle = 1<br/>
Instrument 1: kCycle = 2<br/>
  Instrument 2: kCycle = 2<br/>
    Instrument 3: kCycle = 2</span></p>
<p>Instrument 2 is the first one to initialize, because it is the
only one which is called by the score. Then instrument 3 is
initialized, because it is called first by instrument 2. The last
one is instrument 1. All this is done before the actual performance
begins. In the performance itself, starting from the first control
cycle, all instruments are executed by their order.</p>
<p>Let us compare now what is happening when instrument 2 calls
instrument 1 and 3 <strong>during the performance</strong> (= at
k-time):</p>
<p>   <em><strong>EXAMPLE
03F02_OrderOfExc_event_k.csd</strong></em>  </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
0dbfs = 1
nchnls = 1

instr 1
kCycle timek
prints "Instrument 1 is here at initialization.\n"
printks "Instrument 1: kCycle = %d\n", 0, kCycle
endin

instr 2
kCycle timek
prints "  Instrument 2 is here at initialization.\n"
printks "  Instrument 2: kCycle = %d\n", 0, kCycle
 if kCycle == 1 then
event "i", 3, 0, .02
event "i", 1, 0, .02
 endif
printks "  Instrument 2: still in kCycle = %d\n", 0, kCycle
endin

instr 3
kCycle timek
prints "    Instrument 3 is here at initialization.\n"
printks "    Instrument 3: kCycle = %d\n", 0, kCycle
endin

instr 4
kCycle timek
prints "      Instrument 4 is here at initialization.\n"
printks "      Instrument 4: kCycle = %d\n", 0, kCycle
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 4 0 .02
i 2 0 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>This is the output:<br/>
<span>  Instrument 2 is here at initialization.<br/>
      Instrument 4 is here at initialization.<br/>
  Instrument 2: kCycle = 1<br/>
  Instrument 2: still in kCycle = 1<br/>
      Instrument 4: kCycle = 1<br/>
    Instrument 3 is here at initialization.<br/>
Instrument 1 is here at initialization.<br/>
Instrument 1: kCycle = 2<br/>
  Instrument 2: kCycle = 2<br/>
  Instrument 2: still in kCycle = 2<br/>
    Instrument 3: kCycle = 2<br/>
      Instrument 4: kCycle = 2</span></p>
<p>Instrument 2 starts with its init-pass, and then instrument 4 is
initialized. As you see, the reverse order of the scorelines has no
effect; the instruments which start at the same time are executed
in ascending order, depending on their numbers.</p>
<p>In this first cycle, instrument 2 calls instrument 3 and 1. As
you see by the output of instrument 4, the whole control cycle is
finished first, before instrument 3 and 1 (in this order) are
initialized.<sup data-id="37d38393-1ab8-4662-afaa-e483370944dd" class="endnote">1</sup> 
These both instruments start their performance in cycle number two,
where they find themselves in the usual order: instrument 1 before
instrument 2, then instrument 3 before instrument 4.</p>
<p>Usually you will not need to know all of this with such precise
timing. But in case you experience any problems, a clearer
awareness of the process may help.</p>
<h2>Instrument Events From The Score</h2>
<p>This is the classical way of triggering instrument events: you
write a list in the score section of a .csd file. Each line which
begins with an "i", is an instrument event. As this is very simple,
and examples can be found easily, let us focus instead on some
additional features which can be useful when you work in this way.
Documentation for these features can be found in the <a href="http://www.csounds.com/manual/html/ScoreStatements.html">Score
Statements</a> section of the Canonical Csound Reference Manual.
Here are some examples:</p>
<p>   <em><strong>EXAMPLE
03F03_Score_tricks.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giWav     ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kFadout   init      1
krel      release   ;returns "1" if last k-cycle
 if krel == 1 &amp;&amp; p3 &lt; 0 then ;if so, and negative p3:
          xtratim   .5       ;give 0.5 extra seconds
kFadout   linseg    1, .5, 0 ;and make fade out
 endif
kEnv      linseg    0, .01, p4, abs(p3)-.1, p4, .09, 0; normal fade out
aSig      poscil    kEnv*kFadout, p5, giWav
          outs      aSig, aSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
t 0 120                      ;set tempo to 120 beats per minute
i    1    0    1    .2   400 ;play instr 1 for one second
i    1    2   -10   .5   500 ;play instr 1 indefinetely (negative p3)
i   -1    5    0             ;turn it off (negative p1)
; -- turn on instance 1 of instr 1 one sec after the previous start
i    1.1  ^+1  -10  .2   600
i    1.2  ^+2  -10  .2   700 ;another instance of instr 1
i   -1.2  ^+2  0             ;turn off 1.2
; -- turn off 1.1 (dot = same as the same p-field above)
i   -1.1  ^+1  .
s                            ;end of a section, so time begins from new at zero
i    1    1    1    .2   800
r 5                          ;repeats the following line (until the next "s")
i    1   .25  .25   .2   900
s
v 2                          ;lets time be double as long
i    1    0    2    .2   1000
i    1    1    1    .2   1100
s
v 0.5                        ;lets time be half as long
i    1    0    2    .2   1200
i    1    1    1    .2   1300
s                            ;time is normal now again
i    1    0    2    .2   1000
i    1    1    1    .2   900
s
; -- make a score loop (4 times) with the variable "LOOP"
{4 LOOP
i    1    [0 + 4 * $LOOP.]    3    .2   [1200 - $LOOP. * 100]
i    1    [1 + 4 * $LOOP.]    2    .    [1200 - $LOOP. * 200]
i    1    [2 + 4 * $LOOP.]    1    .    [1200 - $LOOP. * 300]
}
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Triggering an instrument with an indefinite duration by setting
p3 to any negative value, and stopping it by a negative p1 value,
can be an important feature for live events. If you turn
instruments off in this way you may have to add a fade out segment.
One method of doing this is shown in the instrument above with a
combination of the <a href="http://www.csounds.com/manual/html/release.html">release</a> and
the <a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a>
opcodes. Also note that you can start and stop certain instances of
an instrument with a floating point number as p1.</p>
<h2>Using MIDI Note-On Events</h2>
<p>Csound has a particular feature which makes it very simple to
trigger instrument events from a MIDI keyboard. Each MIDI Note-On
event can trigger an instrument, and the related Note-Off event of
the same key stops the related instrument instance. This is
explained more in detail in the chapter <em>Triggering Instrument
Instances</em> in the MIDI section of this manual. Here, just a
small example is shown. Simply connect your MIDI keyboard and it
should work.</p>
<p>   <em><strong>EXAMPLE
03F04_Midi_triggered_events.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          massign   0, 1; assigns all midi channels to instr 1

  instr 1
iFreq     cpsmidi   ;gets frequency of a pressed key
iAmp      ampmidi   8 ;gets amplitude and scales 0-8
iRatio    random    .9, 1.1 ;ratio randomly between 0.9 and 1.1
aTone     foscili   .1, iFreq, 1, iRatio/5, iAmp+1, giSine ;fm
aEnv      linenr    aTone, 0, .01, .01 ; avoiding clicks at the note-end
          outs      aEnv, aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000; play for 10 hours
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using Widgets</h2>
<p>If you want to trigger an instrument event in realtime with a
Graphical User Interface, it is usually a "Button" widget which
will do this job. We will see here a simple example; first
implemented using Csound's FLTK widgets, and then using CsoundQt's
widgets.</p>
<h3>FLTK Button</h3>
<p>This is a very simple example demonstrating how to trigger an
instrument using an <a href="http://www.csounds.com/manual/html/FLbutton.html">FLTK button</a>.
A more extended example can be found <a href="http://www.csounds.com/manual/html/examples/FLbutton.csd">here</a>.</p>
<p>   <em><strong>EXAMPLE
03F05_FLTK_triggered_events.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

      ; -- create a FLTK panel --
          FLpanel   "Trigger By FLTK Button", 300, 100, 100, 100
      ; -- trigger instr 1 (equivalent to the score line "i 1 0 1")k1, ih1   FLbutton  "Push me!", 0, 0, 1, 150, 40, 10, 25, 0, 1, 0, 1
      ; -- trigger instr 2
k2, ih2   FLbutton  "Quit", 0, 0, 1, 80, 40, 200, 25, 0, 2, 0, 1
          FLpanelEnd; end of the FLTK panel section
          FLrun     ; run FLTK
          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; recalculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      poscil    ampdb(idb), cpsoct(ioct)
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

instr 2
          exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Note that in this example the duration of an instrument event is
recalculated when the instrument is initialised. This is done using
the statement "p3 = i...". This can be a useful technique if you
want the duration that an instrument plays for to be different each
time it is called. In this example duration is the result of a
random function'. The duration defined by the FLTK button will be
overwritten by any other calculation within the instrument itself
at i-time.</p>
<h3>CsoundQt Button</h3>
<p>In CsoundQt, a button can be created easily from the submenu in
a widget panel:</p>
<p/><div class="group_img"><div class="image"><img src="static//_v/1.0/http://en.flossmanuals.net/floss/pub/Csound/" alt="" width="0" height="0"/></div></div><div class="group_img"><div class="image"><img title="qcbutton1" src="static/csound-picts-03_cslanguage-qcbutton1-en.png" alt="qcbutton1" width="373" height="520"/> </div></div>
<p>In the Properties Dialog of the button widget, make sure you
have selected "event" as Type. Insert a Channel name, and at the
bottom type in the event you want to trigger - as you would if
writing a line in the score.</p>
<p/><div class="group_img"><div class="image"><img title="qcbutton3" src="static/csound-picts-03_cslanguage-qcbutton3-en.png" alt="qcbutton3" width="542" height="326"/></div></div>
<p>In your Csound code, you need nothing more than the instrument
you want to trigger:</p>
<p/><div class="group_img"><div class="image"><img title="qcbutton4" src="static/csound-picts-03_cslanguage-qcbutton4-en.png" alt="qcbutton4" width="549" height="364"/> </div></div>
<p>For more information about CsoundQt, read the CsoundQt chapter
in the 'Frontends' section of this manual.</p>
<h2>Using A Realtime Score</h2>
<h3>Command Line With The -L stdin Option</h3>
<p>If you use any .csd with the option "-L stdin" (and the -odac
option for realtime output), you can type any score line in
realtime (sorry, this does not work for Windows). For instance,
save this .csd anywhere and run it from the command line:</p>
<p>   <em><strong>EXAMPLE
03F06_Commandline_rt_events.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-L stdin -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; calculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      oscils    ampdb(idb), cpsoct(ioct), 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>If you run it by typing and returning a command line like this
...</p>
<p/><div class="group_img"><div class="image"><img title="cmdline" src="static/csound-picts-03_cslanguage-cmdline-en.png" alt="cmdline" width="640" height="74"/></div></div>
<p>... you should get a prompt at the end of the Csound
messages:</p>
<p/><div class="group_img"><div class="image"><img title="_L1" src="static/csound-picts-03_cslanguage-_l1-en.png" alt="_L1" width="632" height="444"/> </div></div>
<p>If you now type the line "i 1 0 1" and press return, you should
hear that instrument 1 has been executed. After three times your
messages may look like this:</p>
<p/><div class="group_img"><div class="image"><img title="_L2" src="static/csound-picts-03_cslanguage-_l2-en.png" alt="_L2" width="509" height="448"/> </div></div>
<h3>CsoundQt's Live Event Sheet</h3>
<p>In general, this is the method that CsoundQt uses and it is made
available to the user in a flexible environment called the Live
Event Sheet. Have a look in the CsoundQt frontend to see more of
the possibilities of "firing" live instrument events using the Live
Event Sheet.<sup data-id="80b051c6-af18-431c-b8da-2073b8c34ea2" class="endnote">2</sup> </p>
<p/><div class="group_img"><div class="image"><img title="qcs_lesheet" src="static/csound-picts-03_cslanguage-qcs_lesheet-en.png" alt="qcs_lesheet" width="740" height="483"/> </div></div>
<h2>By Conditions</h2>
<p>We have discussed first the classical method of triggering
instrument events from the score section of a .csd file, then we
went on to look at different methods of triggering real time events
using MIDI, by using widgets, and by using score lines inserted
live. We will now look at the Csound orchestra itself and to some
methods by which an instrument can internally trigger another
instrument. The pattern of triggering could be governed by
conditionals, or by different kinds of loops. As this "master"
instrument can itself be triggered by a realtime event, you have
unlimited options available for combining the different
methods.</p>
<p>Let's start with conditionals. If we have a realtime input, we
may want to define a threshold, and trigger an event</p>
<ol>
<li>if we cross the threshold from below to above;</li>
<li>if we cross the threshold from above to below.</li>
</ol>
<p>In Csound, this could be implemented using an orchestra of three
instruments. The first instrument is the master instrument. It
receives the input signal and investigates whether that signal is
crossing the threshold and if it does whether it is crossing from
low to high or from high to low. If it crosses the threshold from
low ot high the second instrument is triggered, if it crosses from
high to low the third instrument is triggered.</p>
<p>   <em><strong>EXAMPLE
03F07_Event_by_condition.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1; master instrument
ichoose   =         p4; 1 = real time audio, 2 = random amplitude movement
ithresh   =         -12; threshold in dB
kstat     init      1; 1 = under the threshold, 2 = over the threshold
;;CHOOSE INPUT SIGNAL
 if ichoose == 1 then
ain       inch      1
 else
kdB       randomi   -18, -6, 1
ain       pinkish   ampdb(kdB)
 endif
;;MEASURE AMPLITUDE AND TRIGGER SUBINSTRUMENTS IF THRESHOLD IS CROSSED
afoll     follow    ain, .1; measure mean amplitude each 1/10 second
kfoll     downsamp  afoll
 if kstat == 1 &amp;&amp; dbamp(kfoll) &gt; ithresh then; transition down-&gt;up
          event     "i", 2, 0, 1; call instr 2
          printks   "Amplitude = %.3f dB%n", 0, dbamp(kfoll)
kstat     =         2; change status to "up"
 elseif kstat == 2 &amp;&amp; dbamp(kfoll) &lt; ithresh then; transition up-&gt;down
          event     "i", 3, 0, 1; call instr 3
          printks   "Amplitude = %.3f dB%n", 0, dbamp(kfoll)
kstat     =         1; change status to "down"
 endif
  endin

  instr 2; triggered if threshold has been crossed from down to up
asig      poscil    .2, 500
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

  instr 3; triggered if threshold has been crossed from up to down
asig      poscil    .2, 400
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000 2 ;change p4 to "1" for live input
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using i-Rate Loops For Calculating A Pool Of Instrument
Events</h2>
<p>You can perform a number of calculations at init-time which lead
to a list of instrument events. In this way you are producing a
score, but inside an instrument. The score events are then executed
later.</p>
<p>Using this opportunity we can introduce the <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a> /
<a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a>
opcode. It is quite similar to the <a href="http://www.csounds.com/manual/html/event.html">event</a> /
<a href="http://www.csounds.com/manual/html/event_i.html">event_i</a>
opcode but has two major benefits:</p>
<ul>
<li>You can write more than one scoreline by using "{{" at the
beginning and "}}" at the end.</li>
<li>You can send a string to the subinstrument (which is not
possible with the event opcode).</li>
</ul>
<p>Let's look at a simple example for executing score events from
an instrument using the scoreline opcode:</p>
<p>   <em><strong>EXAMPLE
03F08_Generate_event_pool.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1 ;master instrument with event pool
          scoreline_i {{i 2 0 2 7.09
                        i 2 2 2 8.04
                        i 2 4 2 8.03
                        i 2 6 1 8.04}}
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>With good right, you might say: "OK, that's nice, but I can also
write scorelines in the score itself!" That's right, but the
advantage with the <em>scoreline_i</em> method is that you can
<strong>render</strong> the score events in an instrument, and
<strong>then</strong> send them out to one or more instruments to
execute them. This can be done with the <a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a>
opcode, which produces the string for scoreline in an i-time loop
(see the chapter about control structures).</p>
<p>   <em><strong>EXAMPLE
03F09_Events_sprintf.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1 ; master instrument with event pool
itimes    =         7 ;number of events to produce
icnt      =         0 ;counter
istart    =         0
Slines    =         ""
loop:               ;start of the i-time loop
idur      random    1, 2.9999 ;duration of each note:
idur      =         int(idur) ;either 1 or 2
itabndx   random    0, 3.9999 ;index for the giPch table:
itabndx   =         int(itabndx) ;0-3
ipch      table     itabndx, giPch ;random pitch value from the table
Sline     sprintf   "i 2 %d %d %.2f\n", istart, idur, ipch ;new scoreline
Slines    strcat    Slines, Sline ;append to previous scorelines
istart    =         istart + idur ;recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop ;end of the i-time loop
          puts      Slines, 1 ;print the scorelines
          scoreline_i Slines ;execute them
iend      =         istart + idur ;calculate the total duration
p3        =         iend ;set p3 to the sum of all durations
          print     p3 ;print it
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1 ;p3 is automatically set to the total duration
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>In this example, seven events have been rendered in an i-time
loop in instrument 1. The result is stored in the string variable
<em>Slines</em>. This string is given at i-time to scoreline_i,
which executes them then one by one according to their starting
times (p2), durations (p3) and other parameters.</p>
<p>Instead of collecting all score lines in a single string, you
can also execute them inside the i-time loop. Also in this way all
the single score lines are added to Csound's event pool. The next
example shows an alternative version of the previous one by adding
the instrument events one by one in the i-time loop, either with
event_i (instr 1) or with scoreline_i (instr 2):</p>
<p>   <em><strong>EXAMPLE
03F10_Events_collected.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1; master instrument with event_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
          event_i   "i", 3, istart, idur, ipch; new instrument event
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 2; master instrument with scoreline_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
Sline     sprintf   "i 3 %d %d %.2f", istart, idur, ipch; new scoreline
          scoreline_i Sline; execute it
          puts      Sline, 1; print it
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 3; plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
i 2 14 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using Time Loops</h2>
<p>As discussed above in the chapter about control structures, a
time loop can be built in Csound either with the <a href="http://www.csounds.com/manual/html/timout.html">timout</a> opcode
or with the <a href="http://www.csounds.com/manual/html/metro.html">metro</a> opcode.
There were also simple examples for triggering instrument events
using both methods. Here, a more complex example is given: A master
instrument performs a time loop (choose either instr 1 for the
timout method or instr 2 for the metro method) and triggers once in
a loop a subinstrument. The subinstrument itself (instr 10)
performs an i-time loop and triggers several instances of a
sub-subinstrument (instr 100). Each instance performs a partial
with an independent envelope for a bell-like additive
synthesis.</p>
<p>   <em><strong>EXAMPLE
03F11_Events_time_loop.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0

  instr 1; time loop with timout. events are triggered by event_i (i-rate)
loop:
idurloop  random    1, 4; duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
idurins   random    1, 5; duration of the triggered instrument
          event_i   "i", 10, 0, idurins; triggers instrument 10
  endin

  instr 2; time loop with metro. events are triggered by event (k-rate)
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 10
          event     "i", 10, 0, kdur; call instr 10
kfreq     random    .25, 1; set new value for trigger frequency
 endif
  endin

  instr 10; triggers 8-13 partials
inumparts random    8, 14
inumparts =         int(inumparts); 8-13 as integer
ibasoct   random    5, 10; base pitch in octave values
ibasfreq  =         cpsoct(ibasoct)
ipan      random    .2, .8; random panning between left (0) and right (1)
icnt      =         0; counter
loop:
          event_i   "i", 100, 0, p3, ibasfreq, icnt+1, inumparts, ipan
          loop_lt   icnt, 1, inumparts, loop
  endin

  instr 100; plays one partial
ibasfreq  =         p4; base frequency of sound mixture
ipartnum  =         p5; which partial is this (1 - N)
inumparts =         p6; total number of partials
ipan      =         p7; panning
ifreqgen  =         ibasfreq * ipartnum; general frequency of this partial
ifreqdev  random    -10, 10; frequency deviation between -10% and +10%
; -- real frequency regarding deviation
ifreq     =         ifreqgen + (ifreqdev*ifreqgen)/100
ixtratim  random    0, p3; calculate additional time for this partial
p3        =         p3 + ixtratim; new duration of this partial
imaxamp   =         1/inumparts; maximum amplitude
idbdev    random    -6, 0; random deviation in dB for this partial
iamp      =   imaxamp * ampdb(idbdev-ipartnum); higher partials are softer
ipandev   random    -.1, .1; panning deviation
ipan      =         ipan + ipandev
aEnv      transeg   0, .005, 0, iamp, p3-.005, -10, 0
aSine     poscil    aEnv, ifreq
aL, aR    pan2      aSine, ipan
          outs      aL, aR
          prints    "ibasfreq = %d, ipartial = %d, ifreq = %d%n",\
                     ibasfreq, ipartnum, ifreq
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 300 ;try this, or the next line (or both)
;i 2 0 300
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Which Opcode Should I Use? </h2>
<p>Csound users are often confused about the variety of opcodes
available to trigger instrument events. Should I use event,
scoreline, schedule or schedkwhen? Should I use event or
event_i?</p>
<p>Let us start with the latter, which actually leads to the
general question about "i-rate" and "k-rate" opcodes.<sup data-id="8d964af5-419b-4bfa-bdce-1b725892226c" class="endnote">3</sup>
In short: Using <strong>event_i</strong> (the i-rate version) will
only trigger an event <strong>once</strong>, when the instrument in
which this opcode works is initiated. Using <strong>event</strong>
(the k-rate version) will trigger an event potentially
<strong>again and again</strong>, as long as the instrument runs,
in each control cycle. This is a very simple example:</p>
<p>   <em><strong>EXAMPLE
03F12_event_i_vs_event.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr=44100
ksmps = 32

;set counters for the instances of Called_i and Called_k
giInstCi init 1
giInstCk init 1

instr Call_i
;call another instrument at i-rate
event_i "i", "Called_i", 0, 1
endin

instr Call_k
;call another instrument at k-rate
event "i", "Called_k", 0, 1
endin

instr Called_i
;report that instrument starts and which instance
prints "Instance #%d of Called_i is starting!\n", giInstCi
;increment number of instance for next instance
giInstCi += 1
endin

instr Called_k
;report that instrument starts and which instance
prints "  Instance #%d of Called_k is starting!\n", giInstCk
;increment number of instance for next instance
giInstCk += 1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;run "Call_i" for one second
i "Call_i" 0 1
;run "Call_k" for 1/100 seconds
i "Call_k" 0 0.01
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Although instrument "Call_i" runs for one second, the call to
instrument "Called_i" is only performed once, because it is done
with event_i: at initialization only. But instrument "Call_k" calls
one instance of "Called_k" in each control cycle; so for the
duration of 0.01 seconds of running instrument "Call_k", fourteen
instances of instrument "Called_k" are being started.<sup data-id="c9c86f79-f31b-4388-8cd8-93026db5c426" class="endnote">4</sup>
So this is the output:</p>
<p><span>Instance #1 of Called_i is starting!<br/>
  Instance #1 of Called_k is starting!<br/>
  Instance #2 of Called_k is starting!<br/>
  Instance #3 of Called_k is starting!<br/>
  Instance #4 of Called_k is starting!<br/>
  Instance #5 of Called_k is starting!<br/>
  Instance #6 of Called_k is starting!<br/>
  Instance #7 of Called_k is starting!<br/>
  Instance #8 of Called_k is starting!<br/>
  Instance #9 of Called_k is starting!<br/>
  Instance #10 of Called_k is starting!<br/>
  Instance #11 of Called_k is starting!<br/>
  Instance #12 of Called_k is starting!<br/>
  Instance #13 of Called_k is starting!<br/>
  Instance #14 of Called_k is starting!</span></p>
<p>So the first (and probably most important) decision in asking
"which opcode should I use", is the answer to the question: "Do I
need an i-rate or a k-rate opcode?"</p>
<h3>i-rate Versions: schedule, event_i, scoreline_i</h3>
<p>If you need an i-rate opcode to trigger an instrument event,
schedule is the most basic choice. You use it actually exactly the
same as writing any score event; just separting the parameter
fields by commas rather by spaces:</p>
<pre>
<strong>schedule</strong> iInstrNum (or "InstrName"), iStart, iDur [, ip4] [, ip5] [...]
</pre>
<p>event_i is very similar:</p>
<pre>
<strong>event_i</strong> "i", iInstrNum (or "InstrName"), iStart, iDur [, ip4] [, ip5] [...]</pre>
<p>The only difference between schedule and event_i is this:
schedule can only trigger instruments, whereas event_i can also
trigger "f" events (= build function tables).</p>
<p>Both, schedule and event_i have a restriction: they are not able
to send strings in the parameter fields p4, p5, ...  So, if
you execute this code ...</p>
<pre>schedule "bla", 0, 1, "blu"
</pre>
<p>... you will get this error message in the console:</p>
<p><span>ERROR:  Unable to find opcode entry for 'schedule'
with matching argument types:<br/>
Found: (null) schedule SccS</span></p>
<p>scoreline_i is designed to make this possible. It takes one or
more lines of score statements which follow the same conventions as
if written in the score section itself.<sup data-id="045763f0-9197-4550-b5aa-d60bac85700b" class="endnote">5</sup>
If you enclose the line(s) by {{ and }}, you can include as many
strings in it as you wish:</p>
<pre>scoreline_i {{
              i "bla" 0 1 "blu" "sound"
              i "bla" 1 1 "brown" "earth"
            }}
</pre>
<h3>k-rate versions: event, scoreline, schedkwhen</h3>
<p>If you need a k-rate opcode to trigger an instrument event,
event is the basic choice. Its syntax is very similar to event_i,
but as described above, it works at k-rate and you can also change
all its arguments at k-rate:</p>
<pre>
<strong>event</strong> "i", kInstrNum (or "InstrName"), kStart, kDur [, kp4] [, kp5] [...]</pre>
<p>Usually, you will not want to trigger another instrument each
control cycle, but based on certain conditions. A very common case
is a "ticking" periodic signal, whichs ticks are being used as
trigger impulses. The typical code snippel using a metro and the
event opcode would be:</p>
<pre>kTrigger  metro    1 ;"ticks" once a second
if kTrigger == 1 then ;if it ticks
  event "i", "my_instr", 0, 1 ;call the instrument
endif
</pre>
<p>In other words: This code would only use one control-cycle per
second to call my_instr, and would do nothing in the other control
cycles. The schedkwhen opcode simplifies such typical use cases,
and adds some other useful arguments. This is the syntax:</p>
<pre>
<strong>schedkwhen</strong> kTrigger, kMinTim, kMaxNum, kInsrNum (or "InstrName"), kStart, kDur [, kp4] [, kp5] [...]
</pre>
<p>The kMinTim parameter specifies the time which has to be spent
between two subsequent calls of the subinstrument. This is often
quite useful as you may want to state: "Do not call the next
instance of the subinstrument unless 0.1 seconds have been passed."
If you set this parameter to zero, there will be no time limit for
calling the subinstrument.</p>
<p>The kMaxNum parameter specifies the maximum number of instances
which run simultaneously. Say, kMaxNum = 2 and there are indeed two
instances of the subinstrument running, no other instance will be
initiated. if you set this parameter to zero, there will be no
limit for calling new instances.</p>
<p>So, with schedkwhen, we can write the above code snippet in two
lines instead of four:</p>
<pre>kTrigger  metro    1 ;"ticks" once a second
schedkwhen kTrigger, 0, 0, "my_instr", 0, 1</pre>
<p>Only, you cannot pass strings as p-fields via schedkwhen (and
event). So, very much similar as described above for i-rate
opcodes, scoreline fills this gap. Usually we will use it with a
condition,  as we did for the event opcode:</p>
<pre>kTrigger  metro    1 ;"ticks" once a second
if kTrigger == 1 then
  ;if it ticks, call two instruments and pass strings as p-fields
  scoreline {{
              i "bla" 0 1 "blu" "sound"
              i "bla" 1 1 "brown" "earth"
            }}
endif</pre>
<h2>Recompilation</h2>
<p>As it has been mentioned at the start of this chapter, since
Csound6 you can re-compile any code in an already running Csound
instance. Let us first see some simple examples for the general
use, and then a more practical approach in CsoundQt.</p>
<h3>compileorc / compilestr</h3>
<p>The opcode compileorc refers to a definition of instruments
which has been saved as an .orc ("orchestra") file. To see how it
works, save this text in a simple text (ASCII) format as
"to_recompile.orc":</p>
<pre>instr 1
iAmp = .2
iFreq = 465
aSig oscils iAmp, iFreq, 0
outs aSig, aSig
endin
</pre>
<p>Then save this csd in the same directory:</p>
<p>   <em><strong>EXAMPLE
03F13_compileorc.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac -d -L stdin -Ma
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 2
ksmps = 32
0dbfs = 1

massign 0, 9999

instr 9999
ires compileorc "to_recompile.orc"
print ires ; 0 if compiled successfully
event_i "i", 1, 0, 3 ;send event
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 9999 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>If you run this csd in the terminal, you should hear a three
seconds beep, and the output should be like this:<br/>
<span>SECTION 1:<br/>
new alloc for instr 9999:<br/>
instr 9999:  ires = 0.000<br/>
new alloc for instr 1:<br/>
B  0.000 ..  1.000 T  1.000 TT  1.000 M: 
0.20000  0.20000<br/>
B  1.000 ..  3.000 T  3.000 TT  3.000 M: 
0.20000  0.20000<br/>
Score finished in csoundPerform().<br/>
inactive allocs returned to freespace<br/>
end of score.          
overall amps:  0.20000  0.20000<br/>
       overall samples out of
range:       
0        0<br/>
0 errors in performance</span></p>
<p>Having understood this, it is easy to do the next step. Remove
(or comment out) the score line "i 9999 0 1" so that the score is
empty. If you start the csd now, Csound will run indefinitely. Now
call instr 9999 by typing "i 9999 0 1" in the terminal window (if
the option -L stdin works for your setup), or by pressing any MIDI
key (if you have connected a keyboard). You should hear the same
beep as before. But as the recompile.csd keeps running, you can
change now the to_recompile.orc instrument. Try, for instance,
another value for kFreq. Whenever this is done (do not forget to
save the file) and you call again instr 9999 in recompile.csd, the
new version of this instrument is compiled and then called
immediately.</p>
<p>The other possibility to recompile code by using an opcode is
compilestr. It will compile any instrument definition which is
contained in a string. As this will be a string with several lines,
you will usually use the '{{' delimiter for the start and '}}' for
the end of the string. This is a basic example:</p>
<p>   <em><strong>EXAMPLE
03F14_compilestr.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 1
ksmps = 32
0dbfs = 1

instr 1

 ;will fail because of wrong code
ires compilestr {{
instr 2
a1 oscilb p4, p5, 0
out a1
endin
}}
print ires ; returns -1 because not successfull

 ;will compile ...
ires compilestr {{
instr 2
a1 oscils p4, p5, 0
out a1
endin
}}
print ires ; ... and returns 0

 ;call the new instrument
 ;(note that the overall performance is extended)
scoreline_i "i 2 0 3 .2 415"

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>As you see, instrument 2 is defined inside instrument 1, and
compiled via compilestr. in case you can change this string in
real-time (for instance in receiving it via OSC), you can add any
new definition of instruments on the fly. But much more elegant is
to use the related method of the Csound API, as CsoundQt does.</p>
<h3>Re-Compilation in CsoundQt</h3>
<p>(The following description is only valid if you have CsoundQt
with PythonQt support. If so, your CsoundQt application should be
called CsoundQt-d-py-cs6 or similar. If the "-py" is missing, you
will probably not have PythonQt support.)</p>
<p>To see how easy it is to re-compile code of a running Csound
instance, load this csd in CsoundQt:</p>
<p>   <em><strong>EXAMPLE
03F15_Recompile_in_CsoundQt.csd</strong></em>   </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 1
ksmps = 32
0dbfs = 1

instr 1
a1 poscil .2, 500
out a1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 1000
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The r-statement repeats the call to instr 1 for 1000 times. Now
change the frequency of 500 in instr 1 to say 800. You will hear no
change, because this has not been compiled yet. But when you now
select the instrument definition (including the instr ... endin)
and then choose Edit -&gt; Evaluate selection, you will hear that
in the next call of instrument 1 the frequency has changed.
(Instead of selecting code and evaluation the selection, you can
also place the cursor inside an instrument and then choose Edit
-&gt; Evaluate section.)</p>
<p>You can also insert new instrument definitions, and then call it
with CsoundQt's Live event sheet. You even need not save it -
instead you can save several results of your live coding without
stopping Csound. Have fun ...</p>
<p> </p>
<p> </p>
<h2>Links And Related Opcodes</h2>
<h3>Links</h3>
<p>A great collection of interactive examples with FLTK widgets by
Iain McCurdy can be found <a href="http://iainmccurdy.org/csound.html">here</a>. See particularily
the "Realtime Score Generation" section. Recently, the collection
has been ported to QuteCsound by René Jopi, and is part of
QuteCsound's example menu.</p>
<p>An extended example for calculating score events at i-time can
be found in the <a href="http://www.joachimheintz.de/soft/popsoft.html">Re-Generation of
Stockhausen's "Studie II"</a> by Joachim Heintz (also included in
the QuteCsound Examples menu).</p>
<h3>Related Opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> /
<a href="http://www.csounds.com/manual/html/event.html">event</a>:
Generate an instrument event at i-time (event_i) or at k-time
(event). Easy to use, but you cannot send a string to the
subinstrument.</p>
<p><a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a>
/ <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a>:
Generate an instrument at i-time (scoreline_i) or at k-time
(scoreline). Like event_i/event, but you can send to more than one
instrument but unlike event_i/event you can send strings. On the
other hand, you must usually preformat your scoreline-string using
sprintf.</p>
<p><a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a> /
<a href="http://www.csounds.com/manual/html/sprintfk.html">sprintfk</a>:
Generate a formatted string at i-time (sprintf) or k-time
(sprintfk), and store it as a string-variable.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-+max_str_len=10000</a>:
Option in the "CsOptions" tag of a .csd file which extend the
maximum string length to 9999 characters.</p>
<p><a href="http://www.csounds.com/manual/html/massign.html">massign</a>:
Assigns the incoming MIDI events to a particular instrument. It is
also possible to prevent any assigment by this opcode.</p>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a> /
<a href="http://www.csounds.com/manual/html/ampmidi.html">ampmidi</a>:
Returns the frequency / velocity of a pressed MIDI key.</p>
<p><a href="http://www.csounds.com/manual/html/release.html">release</a>:
Returns "1" if the last k-cycle of an instrument has begun.</p>
<p><a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a>: Adds
an additional time to the duration (p3) of an instrument.</p>
<p><a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a> /
<a href="http://www.csounds.com/manual/html/turnoff2.html">turnoff2</a>:
Turns an instrument off; either by the instrument itself (turnoff),
or from another instrument and with several options (turnoff2).</p>
<p><a href="http://www.csounds.com/manual/html/i.html">-p3 /
-p</a><span>1</span>: A negative duration
(p3) turns an instrument on "indefinitely"; a negative instrument
number (p1) turns this instrument off. See the examples at the
beginning of this chapter.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-L
stdin</a>: Option in the "CsOptions" tag of a .csd file which lets
you type in realtime score events.</p>
<p><a href="http://www.csounds.com/manual/html/timout.html">timout</a>: Allows
you to perform time loops at i-time with reinitalization
passes.</p>
<p><a href="http://www.csounds.com/manual/html/metro.html">metro</a>: Outputs
momentary 1s with a definable (and variable) frequency. Can be used
to perform a time loop at k-rate.</p>
<p><a href="http://www.csounds.com/manual/html/follow.html">follow</a>:
Envelope follower.</p>
<ol class="endnotes">
<li id="endnote-37d38393-1ab8-4662-afaa-e483370944dd">This has been described incorrectly in the
first two issues of this manual.</li><li id="endnote-80b051c6-af18-431c-b8da-2073b8c34ea2">There are also some video tutorials:
http://www.youtube.com/watch?v=O9WU7DzdUmE
http://www.youtube.com/watch?v=Hs3eO7o349k
http://www.youtube.com/watch?v=yUMzp6556Kw</li><li id="endnote-8d964af5-419b-4bfa-bdce-1b725892226c">See chapter 03A about Initialization and
Performance Pass for a detailed discussion.</li><li id="endnote-c9c86f79-f31b-4388-8cd8-93026db5c426">As for a sample rate of 44100 Hz
(sr=44100) and a control period od 32 samples (ksmps=32), we have
1378 control periods in one second. So 0.01 seconds will perform 14
control cycles.</li><li id="endnote-045763f0-9197-4550-b5aa-d60bac85700b">This means that score parameter fields are
separated by spaces, not by commas.</li></ol>
</body>
</html>
