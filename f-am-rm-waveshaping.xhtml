<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>F. AM / RM / WAVESHAPING</title>
  </head>
  <body><h1>F. AM / RM / WAVESHAPING</h1><p>Csound: AMRMWAVESHAPING</p>
<p>An introduction as well as some background theory of amplitude
modulation, ring modulation and waveshaping is given in the fourth
chapter entitled "sound-synthesis". As all of these techniques
merely modulate the amplitude of a signal in a variety of ways,
they can also be used for the modification of non-synthesized
sound. In this chapter we will explore amplitude modulation, ring
modulation and waveshaping as applied to non-synthesized
sound.<sup data-id="e24221b6-a525-4a6a-8aa9-42071e49246d" class="endnote">1</sup> </p>
<h2>AMPLITUDE MODULATION</h2>
<p>With "sound-synthesis", the principle  of AM was shown as a
amplitude multiplication of two sine oscillators. Later we've used
a more complex modulators, to generate more complex spectrums. The
principle also works very well with sound-files (samples) or
live-audio-input.</p>
<p>Karlheinz Stockhausens <em>"Mixtur für Orchester, vier
Sinusgeneratoren und vier Ringmodulatoren</em>” (1964) was the
first piece which used analog ringmodulation (AM without DC-offset)
to alter the acoustic instruments pitch in realtime during a
live-performance. The word ringmodulation inherites from the analog
<em>four-diode circuit</em> which was arranged in a "ring".</p>
<p>In the following example shows how this can be done digitally in
Csound. In this case a sound-file works as the <em>carrier</em>
which is modulated by a <em>sine-wave-osc</em>. The result sounds
like old 'Harald Bode' pitch-shifters from the 1960's.</p>
<p><strong><em>EXAMPLE: 05F01_RM_modification.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1


instr 1   ; Ringmodulation
aSine1     poscil     0.8, p4, 1
aSample    diskin2    "fox.wav", 1, 0, 1, 0, 32
           out        aSine1*aSample
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 ; sine

i 1 0 2 400
i 1 2 2 800
i 1 4 2 1600
i 1 6 2 200
i 1 8 2 2400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)
</pre>
<h2>WAVESHAPING</h2>
<p>In chapter 04E waveshaping has been described as a method of
applying a transfer function to an incoming signal. It has been
discussed that the table which stores the transfer function must be
read with an interpolating table reader to avoid degradation of the
signal. On the other hand, degradation can be a nice thing for
sound modification. So let us start with this branch here.</p>
<h3>Bit Depth Reduction</h3>
<p>If the transfer function itself is linear, but the table of the
function is small, and no interpolation is applied to the amplitude
as index to the table, in effect the bit depth is reduced. For a
function table of size 4, a line becomes a staircase:</p>
<p>Bit Depth =
high                     
                 
        </p>
<p/><div class="group_img"><div class="image"><img src="static/05fbild1a.png" alt="" width="599" height="599"/></div></div>
<p>Bit Depth = 2</p>
<p/><div class="group_img"><div class="image"><img src="static/05fbild2a.png" alt="" width="601" height="601"/></div></div>
<p>This is the sounding result:</p>
<p><em><strong>EXAMPLE 05F02_Wvshp_bit_crunch.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giTrnsFnc ftgen 0, 0, 4, -7, -1, 3, 1

instr 1
aAmp      soundin   "fox.wav"
aIndx     =         (aAmp + 1) / 2
aWavShp   table     aIndx, giTrnsFnc, 1
          outs      aWavShp, aWavShp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2.767
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h3>Transformation and Distortion</h3>
<p>In general, the transformation of sound in applying waveshaping
depends on the transfer function. The following example applies at
first a table which does not change the sound at all, because the
function just says <em>y = x</em>. The second one leads aready to a
heavy distortion, though "just" the samples between an amplitude of
-0.1 and +0.1 are erased. Tables 3 to 7 apply some chebychev
functions which are well known from waveshaping synthesis. Finally,
tables 8 and 9 approve that even a meaningful sentence and a nice
music can regarded as noise ...</p>
<p><em><strong>EXAMPLE
05F03_Wvshp_different_transfer_funs.csd</strong></em></p>
<p> </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giNat   ftgen 1, 0, 2049, -7, -1, 2048, 1
giDist  ftgen 2, 0, 2049, -7, -1, 1024, -.1, 0, .1, 1024, 1
giCheb1 ftgen 3, 0, 513, 3, -1, 1, 0, 1
giCheb2 ftgen 4, 0, 513, 3, -1, 1, -1, 0, 2
giCheb3 ftgen 5, 0, 513, 3, -1, 1, 0, 3, 0, 4
giCheb4 ftgen 6, 0, 513, 3, -1, 1, 1, 0, 8, 0, 4
giCheb5 ftgen 7, 0, 513, 3, -1, 1, 3, 20, -30, -60, 32, 48
giFox   ftgen 8, 0, -121569, 1, "fox.wav", 0, 0, 1
giGuit  ftgen 9, 0, -235612, 1, "ClassGuit.wav", 0, 0, 1

instr 1
iTrnsFnc  =         p4
kEnv      linseg    0, .01, 1, p3-.2, 1, .01, 0
aL, aR    soundin   "ClassGuit.wav"
aIndxL    =         (aL + 1) / 2
aWavShpL  tablei    aIndxL, iTrnsFnc, 1
aIndxR    =         (aR + 1) / 2
aWavShpR  tablei    aIndxR, iTrnsFnc, 1
          outs      aWavShpL*kEnv, aWavShpR*kEnv
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7 1 ;natural though waveshaping
i 1 + . 2 ;rather heavy distortion
i 1 + . 3 ;chebychev for 1st partial
i 1 + . 4 ;chebychev for 2nd partial
i 1 + . 5 ;chebychev for 3rd partial
i 1 + . 6 ;chebychev for 4th partial
i 1 + . 7 ;after dodge/jerse p.136
i 1 + . 8 ;fox
i 1 + . 9 ;guitar
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Instead of using the "self-built" method which has been
described here, you can use the Csound opcode <a href="http://www.csounds.com/manual/html/distort.html">distort</a>. It
performs the actual waveshaping process and gives a nice control
about the amount of distortion in the <em>kdist</em> parameter.
Here is a simple example:<sup data-id="10b2a749-7153-4f8d-b4b1-d21416632ae8" class="endnote">2</sup> </p>
<p><em><strong>EXAMPLE 05F04_distort.csd</strong></em></p>
<p> </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

gi1 ftgen 1,0,257,9,.5,1,270 ;sinoid (also the next)
gi2 ftgen 2,0,257,9,.5,1,270,1.5,.33,90,2.5,.2,270,3.5,.143,90
gi3 ftgen 3,0,129,7,-1,128,1 ;actually natural
gi4 ftgen 4,0,129,10,1 ;sine
gi5 ftgen 5,0,129,10,1,0,1,0,1,0,1,0,1 ;odd partials
gi6 ftgen 6,0,129,21,1 ;white noise
gi7 ftgen 7,0,129,9,.5,1,0 ;half sine
gi8 ftgen 8,0,129,7,1,64,1,0,-1,64,-1 ;square wave

instr 1
ifn       =         p4
ivol      =         p5
kdist     line      0, p3, 1 ;increase the distortion over p3
aL, aR    soundin   "ClassGuit.wav"
aout1     distort   aL, kdist, ifn
aout2     distort   aR, kdist, ifn
          outs      aout1*ivol, aout2*ivol
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7 1 1
i . + . 2 .3
i . + . 3 1
i . + . 4 .5
i . + . 5 .15
i . + . 6 .04
i . + . 7 .02
i . + . 8 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p> </p>
<ol class="endnotes">
<li id="endnote-e24221b6-a525-4a6a-8aa9-42071e49246d">This is the same for Granular Synthesis
which can either be "pure" synthesis or applied so sampled
sound.</li><li id="endnote-10b2a749-7153-4f8d-b4b1-d21416632ae8">Have a look at Iain McCurdy's Realtime
example (which has also been ported to CsoundQt by René Jopi) for
'distort' for a more interactive exploration of the
opcode.</li></ol>
</body>
</html>
