<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>E. CSOUND IN iOS</title>
  </head>
  <body><h1>E. CSOUND IN iOS</h1><p>Note: this chapter can be found in PDF form <a href="https://www.dropbox.com/s/319wxt38l9ncllx/CsoundiOS_AGuide.pdf?dl=0">
here</a> and the Csound iOS SDK can be downloaded <a href="http://csound.github.io/download">here</a>.</p>
<h3><strong>1 Introduction</strong></h3>
<p>This guide aims to introduce and illustrate some of the power
that the Csound language offers to iOS Developers. It assumes that
the reader has a rudimentary background in Csound, and some
experience and understanding of iOS development with either Swift
or Objective-C.</p>
<p><strong>1.1 Csound for iOS</strong></p>
<p>Csound for iOS offers the developer a number of powerful tools
have been created to aid in the development of audio software for
Apple's iOS platform. Here we describe a promising avenue for audio
programmers, and especially for those with some background in
Csound: the Csound for iOS API. We hope that it will serve as a
guide to those who hope to advance or diversify as audio
programmers for iOS by harnessing the powerful synthesis,
signal-processing, and other capabilities of Csound and the Csound
API.</p>
<p>The Csound for iOS Manual (Lazzarini, Yi, Boulanger) that ships
with the Csound for iOS API is intended to serve as a lighter
reference for developers. This guide is distinct from it in that it
is intended to be a more thorough, step-by-step approach to
learning the API for the first time. <br/></p>
<h3><strong>2 Getting Started</strong></h3>
<p>There are a number of ways in which one might begin to learn to
work with the Csound for iOS API. Here, to aid in exploring it, we
first describe how the project of examples that ships with the API
is structured. We then talk about how to go about configuring a new
iOS Xcode project to work with Csound from scratch.</p>
<p><strong>2.1 Csound for iOS Examples</strong></p>
<p>The Csound for iOS Examples project contains a number of simple
examples (in both Objective-C and Swift) of how one might use
Csound’s synthesis and signal processing capabilities, and the
communicative functionality of the API.</p>
<p>In the ’ViewControllers’ group, a number of subgroups exist to
organize the various individual examples into a single application.
This is done using the Master-Detail application layout paradigm,
wherein a set of options, all of them listed in a ’master’ table,
correlates to a single ’detail’ ViewController. Familiar examples
of this design model, employed by Apple and provided with every iOS
device, are the Settings app, and the Notes app – each of these
contains a master table upon which the detail ViewController’s
content is predicated.</p>
<p>In each of these folders, you will find a unique example
showcasing how one might use some of the features of the Csound for
iOS API to communicate with Csound to produce and process sounds
and make and play music. These are designed to introduce you to
these features in a practical setting, and etch of these has a
unifying theme that informs its content, interactions, and
structure.</p>
<p><strong>2.2 Adding Csound to Your Project</strong></p>
<p>If you are working in Objective-C, adding Csound for iOS to your
project is as simple as dragging the csound-iOS folder into your
project. You should select "Groups" rather than "Folder
References", and it is recommended that you elect to copy the
csound-iOS folder into your project folder ("Copy Items if
Needed").</p>
<p>Once you have successfully added this folder, including the
CsoundObj class (the class that manages Csound on iOS) is as simple
as adding an import statement to the class. For example:</p>
<pre><span>//</span><br/><span>// ViewController.h</span><br/><span>//</span><br/><span>#import "CsoundObj.h"</span></pre>
<p>Note that this only makes the CsoundObj class available, which
provides an interface for Csound. There are other objects
containing UI and CoreMotion bindings, as well as MIDI handling.
These are discussed later in this document, and other files will
need to be imported in order to access them.</p>
<p>For Swift users, the process is slightly different: you will
need to first create a "bridging header": a .h header file that can
import the Objective-C API for access in Swift. The naming
convention is [YourProjectName]-Bridging Header.h and this file can
be easily created manually in Xcode by choosing File &gt; New &gt;
File &gt; Header File (Under ’Source’), and using the naming
convention described above. After this, you will need to navigate
to your project build settings and add the path to this file
(relative to your project’s .xcodeproj project file).</p>
<p>Once this is done, navigate to the bridging header in Xcode and
add your Objective-C #import statements here. For example:</p>
<pre><span>//</span><br/><span>// CsoundiOS_ExampleSwift-Bridging-Header.h</span><br/><span>// CsoundiOS_ExampleSwift</span><br/><span>//</span></pre>
<pre><span>#ifndef CsoundiOS_ExampleSwift_Bridging_Header_h</span><br/><span>#define CsoundiOS_ExampleSwift_Bridging_Header_h</span></pre>
<pre><span>#import "CsoundObj.h"</span></pre>
<pre><span>#endif /* CsoundiOS_ExampleSwift_Bridging_Header_h */</span></pre>
<p>You do not need to add any individual import statements to Swift
files, CsoundObj’s functionality should be accessible in your
.swift files after this process is complete.</p>
<p><strong>2.3 Playing a .csd File</strong></p>
<p>The first thing we will do so that we can play a .csd file is
add our .csd file to our project. In this case, we will add a
simple .csd (in this case named test.csd) that plays a sine tone
with a frequency of 440Hz for ten seconds. Sample Csound code for
this is:</p>
<pre><span>&lt;CsoundSynthesizer&gt;</span><br/><span>&lt;CsOptions&gt;</span><br/><span>-odac</span><br/><span>&lt;/CsOptions&gt;</span><br/><span>&lt;CsInstruments&gt;</span></pre>
<pre><br/><span>sr = 44100</span><br/><span>ksmps = 128</span><br/><span>nchnls = 2</span><br/><span>0dbfs = 1</span></pre>
<pre><br/><span>instr 1</span><br/><span>asig poscil 0.5 , 440</span><br/><span>outs asig , asig</span><br/><span>endin</span></pre>
<pre><br/><span>&lt;/CsInstruments&gt;</span><br/><span>&lt;CsScore&gt;</span><br/><span>i1 0 10</span><br/><span>&lt;/CsScore&gt;</span><br/><span>&lt;/CsoundSynthesizer&gt;</span></pre>
<p>We will add this to our Xcode project by dragging and dropping
it into our project’s main folder, making sure to select "Copy
items if needed" and to add it to our main target.</p>
<p>In order to play this .csd file, we must first create an
instance of the CsoundObj class. We can do this by creating a
property of our class as follows, in our .h file (for example, in
ViewController.h):</p>
<pre><span>//</span><br/><span>// ViewController.h</span><br/><span>// CsoundiOS_ExampleProject</span><br/><span>//</span></pre>
<pre><span>#import &lt;UIKit/UIKit.h&gt;</span><br/><span>#import "CsoundObj.h"</span></pre>
<pre><br/><span>@interface ViewController : UIViewController</span></pre>
<pre><span>@property CsoundObj *csound;</span></pre>
<pre><span>@end</span></pre>
<p>Once we’ve done this, we can move over to the corresponding .m
file (in this case, ViewController.m) and instantiate our Csound
object. Here we will do this in our viewDidLoad method, that is
called when our ViewController’s view loads.</p>
<pre><span>//</span><br/><span>// ViewController.m</span><br/><span>// CsoundiOS_ExampleProject</span><br/><span>//</span></pre>
<pre><br/><span>@interface ViewController()</span><br/><span>@end</span><br/><span>@implementation ViewController</span></pre>
<pre><br/><span>- (void)viewDidLoad {</span><br/><span>    [super viewDidLoad];</span><br/><span>    // Allocate memory for and initialize a CsoundObj</span><br/><span>    self.csound = [[CsoundObj alloc] init];</span><br/><span>}</span></pre>
<p>Note: in order to play our .csd file, we must first get a path
to it that we can give Csound. Because part of this path can vary
depending on certain factors (for example, the user’s native
language setting), we cannot pass a static or "hard-coded" path.
Instead, we will access the file using the NSBundle class (or
’Bundle’ in Swift).</p>
<p>The .csd file is copied as a resource (you can see this under
the ’Build Phases’ tab in your target’s settings), and so we will
access it and tell Csound to play it as follows:</p>
<pre><span>- (void)viewDidLoad {</span><br/><span>    [super viewDidLoad];</span><br/><span>    self.csound = [[CsoundObj alloc] init];</span><br/><span>    //CsoundObj *csound is declared as a property in .h</span><br/><span>    NSString *pathToCsd = [[NSBundle mainBundle] pathForResource: @"test" </span><span>ofType:@ "csd"];</span><br/><span>    [self.csound play:pathToCsd];</span><br/><span>}</span></pre>
<p>Note that in Swift, this is a little easier and we can simply
use:</p>
<pre><span>import UIKit</span><br/><span>class ViewController: UIViewController {</span><br/><span>    var csound = CsoundObj()</span></pre>
<pre><span>    override func viewDidLoad() {</span><br/><span>        super.viewDidLoad()</span><br/><span>        let pathToCsd = Bundle.main.path(forResource: "test", ofType: "csd")</span><br/><span>        self.csound.play(pathToCsd)</span><br/><span>    }</span><br/><span>}</span></pre>
<p>With this, the test.csd file should load and play, and we should
hear a ten-second long sine tone shortly after the application runs
(i.e. when the main ViewController’s main view loads).</p>
<h3><strong>3 Recording and Rendering</strong></h3>
<p><strong>3.1 Recording (Real-Time)</strong></p>
<p>To record the output of Csound in real-time, instead of the play
method, use:</p>
<pre><span>// Objective-C</span><br/><span>NSURL *docsDirURL = [[[NSFileManager defaultManager] </span><span>URLsForDirectory:NSDocumentDirectory </span><span>inDomains:NSUserDomainMask] </span><span>lastObject];</span><br/><span>NSURL *file = [docsDirURL URLByAppendingPathComponent:@"outputFile.aif"];</span><br/><span>NSString *csdPath = [[NSBundle mainBundle] pathForResource:@"csdToRecord" </span><span>ofType:@"csd"];</span><br/><span>[self.csound record:csdPath toURL:file];</span></pre>
<pre><span>// Swift</span><br/><span>let docsDirURL = FileManager.default.urls(for: .documentDirectory, </span><span>in: .userDomainMask)[0]</span><br/><span>let file = docsDirURL.appendingPathComponent("outFile.aif")</span><br/><span>let csdPath = Bundle.main.path(forResource: "csdFile", ofType: "csd")</span><br/><span>csound.record(csdPath, to: file)</span></pre>
<p>Alternatively, the recordToURL method can be used while Csound
is already running to begin recording:</p>
<pre><span>// Objective-C</span><br/><span>NSURL *docsDirURL = [[[NSFileManager defaultManager] </span><span>URLsForDirectory:NSDocumentDirectory </span><span>inDomains:NSUserDomainMask] </span><span>lastObject];</span><br/><span>NSURL *file = [docsDirURL URLByAppendingPathComponent:@"outputFile.aif"];</span><br/><span>[self.csound recordToURL:file];</span></pre>
<pre><span>// Swift</span><br/><span>let docsDirURL = FileManager.default.urls(for: .documentDirectory, </span><span>in: .userDomainMask)[0]</span><br/><span>let file = docsDirURL.appendingPathComponent("outFile.aif")</span><br/><span>csound.record(to: file)</span></pre>
<p>Note: the stopRecording method is used to stop recording without
also stopping Csound’s real-time rendering.</p>
<p><strong>3.2 Rendering (Offline)</strong></p>
<p>You can also render a .csd to an audio file offline. To render
Csound offline to disk, use the record:toFile: method, which takes
a path rather than a URL as its second argument. For example:</p>
<pre><span>// Objective-C</span><br/><span>NSString *docsDir = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, </span><span>NSUserDomainMask, YES)[0];</span><br/><span>NSString *file = [docsDir stringByAppendingPathComponent:@"outFile.aif"];</span><br/><span>NSString *csdPath = [[NSBundle mainBundle] pathForResource:@"csdFile" </span><span>ofType:@"csd"];</span><br/><span>[self record:csdPath toFile:file];</span></pre>
<pre><span>// Swift</span><br/><span>let docsDir = NSSearchPathForDirectoriesInDomains(.documentDirectory, </span><span>.userDomainMask, true)[0]</span><br/><span>let file = docsDir.appending("/outFile.aif")</span><br/><span>let csdPath = Bundle.main.path(forResource: "csdFile", ofType: "csd")</span><br/><span>csound.record(csdPath, toFile: file)</span></pre>
<p>These demonstrations above save the audio files in the app’s
documents directory, which allows write access for file and
subdirectory storage on iOS. Note that the -W and -A flags behave
as usual on iOS: they will decide whether the file rendered is a
WAV or an AIFF file. In the event that neither is provided, the
latter will be used as a default.</p>
<h3><strong>4 The CsoundUI Class</strong></h3>
<p>The CsoundUI class provides for direct bindings between named
Csound channels and commonly used objects from the UIKit iOS
framework. While it is not necessary to use a CsoundUI object for
this communication between iOS and Csound, it can, in many cases,
abstract the process of setting up a UI object binding to a single
line of code. To initialize a CsoundUI object, we must give it a
reference to our Csound object:</p>
<pre><span>//Objective-C</span><br/><span>CsoundUI *csoundUI = [[CsoundUI alloc] initWithCsoundObj: self.csound];</span></pre>
<pre><span>// Swift</span><br/><span>var csoundUI = CsoundUI(csoundObj: csound)</span></pre>
<p>Normally, however, these objects are declared as properties
rather than locally in methods. As mentioned, CsoundUI uses named
channels for communicating to and from Csound. Once set-up, values
passed to these named channels are normally accessed through the
chnget opcode, for example:</p>
<pre><span>instr 1</span><br/><span>kfreq chnget " frequency "</span><br/><span>asig oscil 0.5 , kfreq</span><br/><span>outs asig , asig</span><br/><span>endin</span></pre>
<p>Conversely, in order to pass values from Csound, the chnset
opcode is normally used with two arguments. The first is the
variable, and it is followed by the channel name:</p>
<pre><span>instr 1</span><br/><span>krand randomi 300 , 2000 , 1 , 3</span><br/><span>asig poscil 0.5 , krand</span><br/><span>outs asig , asig</span><br/><span>chnset krand , " randFreq "</span><br/><span>endin</span></pre>
<p><br/>
<strong>4.1 UIButton Binding</strong></p>
<p>The UIButton binding is predominantly contained within the
CsoundButtonBinding class, which CsoundUI uses to create individual
button bindings. To add a button binding, use:</p>
<pre><span>//Objective-C</span><br/><span>[self.csoundUI addButton:self.button </span><span>forChannelName:"channelName"];</span></pre>
<pre><span>// Swift</span><br/><span>csoundUI.add(button, forChannelName: "channelName")</span></pre>
<p>Where self.button is the button you would like to bind to, and
the string "channelName" contains the name of the channel
referenced by chnget in Csound.</p>
<p>The corresponding value in Csound will be equal to 1 while the
button is touched, and reset to 0 when it is released. A simple
example of how this might be used in Csound, based on the pvscross
example by Joachim Heintz, is shown below:</p>
<pre><span>instr 1</span><br/><span>kpermut chnget " crossToggle "</span><br/><span>ain1 soundin " fox .wav"</span><br/><span>ain2 soundin " wave .wav"</span></pre>
<pre><span>;fft - analysis of file 1</span><br/><span>fftin1 pvsanal ain1 , 1024 , 256 , 1024 , 1</span><br/><span>;fft - analysis of file 2</span><br/><span>fftin2 pvsanal ain2 , 1024 , 256 , 1024 , 1</span></pre>
<pre><span>if kpermut == 1 then</span><br/><span>fcross pvscross fftin2 , fftin1 , .5 , .5</span><br/><span>else</span><br/><span>fcross pvscross fftin1 , fftin2 , .5 , .5</span><br/><span>endif</span></pre>
<pre><span>aout pvsynth fcross</span><br/><span>out aout</span><br/><span>endin</span></pre>
<p><strong>4.2 UISwitch Binding</strong></p>
<p>The UISwitch binding provides a connection between the UISwitch
object and a named channel in Csound. This binding is managed in
the CsoundSwitchBinding class and you can create a UISwitch binding
by using:</p>
<pre><span>//Objective-C</span><br/><span>[self.csoundUI addSwitch:self.uiSwitch </span><span>forChannelName:"channelName"];</span></pre>
<pre><span>// Swift</span><br/><span>csoundUI.add(switch, forChannelName: "channelName")</span></pre>
<p>As in the case of the UIButton binding, the UISwitch binding
provides an on-off state value (1 or 0 respectively) to Csound.
Below we use it to turn on or off a simple note generator:</p>
<pre><span>; Triggering instrument</span><br/><span>instr 1</span><br/><span>kTrigFreq randomi gkTrigFreqMin , gkTrigFreqMax , 5</span><br/><span>ktrigger metro kTrigFreq</span><br/><span>kdur randomh .1 , 2 , 5</span><br/><span>konoff chnget " instrToggle "</span><br/><span>if konoff == 1 then</span><br/><span>schedkwhen ktrigger , 0 , 0 , 2 , 0 , kdur</span><br/><span>endif</span><br/><span>endin</span></pre>
<pre><span>; Sound generating instrument</span><br/><span>instr 2</span><br/><span>iamp random 0.03 ,0.5</span><br/><span>ipan random 0 , 1</span><br/><span>ipdx random 0 ,13</span><br/><span>ipch table ipdx , 2+i( gkscale )</span><br/><span>aenv expseg 1 , ( p3 ) , .001</span><br/><span>asig oscil iamp * aenv , cpspch(ipch) , 1</span><br/><span>outs asig * ipan , asig * (1 - ipan)</span><br/><span>endin</span></pre>
<p><strong>4.3 UILabel Binding</strong></p>
<p>The UILabel binding allows you to display any value from Csound
in a UILabel object. This can often be a helpful way of providing
feedback to the user. You can add a label binding with:</p>
<pre><span>//Objective-C</span><br/><span>[self.csoundUI addLabel:self.label </span><span>forChannelName:"channelName"];</span></pre>
<pre><span>// Swift</span><br/><span>csoundUI.add(label, forChannelName: "channelName")</span></pre>
<p>However, in this case the channel is an output channel. To
demonstrate, let us add an output channel in Csound to display the
frequency of the sound generating instrument’s oscillator from the
previous example (for UISwitch):</p>
<pre><span>; Triggering instrument</span><br/><span>instr 1</span><br/><span>kTrigFreq randomi gkTrigFreqMin , gkTrigFreqMax , 5</span><br/><span>ktrigger metro kTrigFreq</span><br/><span>kdur randomh .1 , 2 , 5</span><br/><span>konoff chnget " instrToggle "</span><br/><span>if konoff == 1 then</span><br/><span>schedkwhen ktrigger , 0 , 0 , 2 , 0 , kdur</span><br/><span>endif</span><br/><span>endin</span></pre>
<pre><span>; Sound generating instrument</span><br/><span>instr 2</span><br/><span>iamp random 0.03 ,0.5</span><br/><span>ipan random 0 , 1</span><br/><span>ipdx random 0 ,13</span><br/><span>ipch table ipdx , 2+i( gkscale )</span><br/><span>aenv expseg 1 , ( p3 ) , .001</span><br/><span>asig oscil iamp * aenv , cpspch(ipch) , 1</span><br/><span>chnset cpspch(ipch) , " pitchOut "</span><br/><span>outs asig * ipan , asig * (1 - ipan)</span><br/><span>endin</span></pre>
<p>Note additionally that the desired precision of the value
display can be set beforehand using the labelPrecision property of
the CsoundUI object. For example:</p>
<pre><span>self.csoundUI.labelPrecision = 4;</span></pre>
<p><strong>4.4 UISlider Binding</strong></p>
<p>The UISlider binding is possibly the most commonly used UI
binding - it allows the value of a UISlider object to be passed to
Csound whenever it changes. This is set up in the
CsoundSliderBinding class and we access it via CsoundUI using:</p>
<pre><span>// Objective-C</span><br/><span>[self.csoundUI addSlider:self.slider</span><br/><span>forChannelName:"channelName"];</span></pre>
<pre><span>// Swift</span><br/><span>csoundUI.add(slider, forChannelName: "channelName")</span></pre>
<p>Note that this restricts you to using the slider’s actual value,
rather than a rounded verion of it or some other variation, which
would normally be best suited to a manual value binding, which is
addressed later in this guide. An example is provided below of two
simple such UISlider-bound values in Csound:</p>
<pre><span>sr = 44100</span><br/><span>ksmps = 128</span><br/><span>nchnls = 2</span><br/><span>0dbfs = 1</span></pre>
<pre><span>instr 1</span><br/><span>kfreq chnget " frequency " ; input 0 - 1</span><br/><span>kfreq expcurve kfreq , 500 ; exponential distribution</span><br/><span>kfreq *= 19980 ; scale to range</span><br/><span>kfreq += 20 ;add offset</span><br/><span>kamp chnget " amplitude "</span><br/><span>kamp port kamp , .001 ; smooth values</span><br/><span>asig poscil kamp , kfreq</span><br/><span>outs asig , asig</span><br/><span>endin</span></pre>
<p>Above we get ’around’ being restricted to the value of the
UISlider by creating an exponential distribution in Csound. Of
course we could simply make the minimum and maximum values of the
UISlider 20 and 20000 respectively, but that would be a linear
distribution by default. In both cases here, the UISlider’s range
of floating point values is set to be from 0 to 1.</p>
<p><strong>4.5 Momentary Button Binding</strong></p>
<p>The momentary button binding is similar to the normal UIButton
binding in that it uses a UIButton, however it differs in how it
uses this object. The UIButton binding passes a channel value of 1
for as long as the UIButton is held, whereas the momentary button
binding sets the channel value to 1 for one Csound k-period (i.e.
one k-rate sample). It does this by setting an intermediate value
to 1 when the button is touched, passing this to Csound on the next
k-cycle, and immediately resetting it to 0 after passing it. This
is all occurring predominantly in the CsoundMomentaryButtonBinding
class, which we access using:</p>
<pre><span>// Objective-C</span><br/><span>[self.csoundUI addMomentaryButton:self.triggerButton </span><span>forChannelName:"channelName"];</span></pre>
<pre><span>// Swift</span><br/><span>csoundUI.addMomentaryButton(triggerButton, forChannelName: "channelName")</span></pre>
<p>Here’s a simple usage example:</p>
<pre><span>; Triggering instrument</span><br/><span>instr 1</span><br/><span>ktrigger chnget " noteTrigger "</span><br/><span>schedkwhen ktrigger , 0 , 0 , 2 , 0 , kdur</span><br/><span>endin</span></pre>
<pre><span>; Sound generating instrument</span><br/><span>instr 2</span><br/><span>iamp random 0.03 ,0.5</span><br/><span>ipan random 0 , 1</span><br/><span>ipdx random 0 ,13</span><br/><span>ipch table ipdx , 2+i( gkscale )</span><br/><span>aenv expseg 1 , ( p3 ) , .001</span><br/><span>asig oscil iamp * aenv , cpspch(ipch) , 1</span><br/><span>chnset cpspch(ipch) , " pitchOut "</span><br/><span>outs asig * ipan , asig * (1 - ipan)</span><br/><span>endin</span></pre>
<p>This replaces the automatic instrument triggering with a manual
trigger. Every time the UIButton is touched, a note (by way of an
instance of instr 2) will be triggered. This may seem like a more
esoteric binding, but there are a variety of potential uses.</p>
<h3><strong>5 The CsoundMotion Class</strong></h3>
<p>The CsoundMotion class and its associated bindings allow
information to be passed from a device’s motion sensors, via the
CoreMotion framework, to Csound. As with CsoundUI, it is possible
to pass this data indirectly by writing code to mediate between
CoreMotion and Csound, but CsoundMotion simplifies and greatly
abstracts this process. Subsection 4.4 shows an example of how
these values are accessed and might be used in Csound. Note that
with CsoundMotion, you do not assign channel names: they are
pre-assigned by the relevant objects (e.g. "AccelerometerX").</p>
<p>To declare and initialize a CsoundMotion object, use:</p>
<pre><span>// Objective-C</span><br/><span>CsoundMotion *csoundMotion = [[CsoundMotion alloc] </span><span>initWithCsoundObj:self.csound];</span></pre>
<pre><span>// Swift</span><br/><span>var csoundMotion = CsoundMotion(csoundObj: csound)</span></pre>
<p>As with CsoundUI, it may often be advantageous to declare the
CsoundMotion object as a property rather than locally.</p>
<p><strong>5.1 Accelerometer Binding</strong></p>
<p>The acclerometer binding, implemented in the
CsoundAccelerometerBinding class and enabled through the
CsoundMotion class, allows access to an iOS device’s accelerometer
data along its three axes (X, Y, Z). The accelerometer is a device
that measures acceleration, aiding in several basic interactions.
To enable it, use:</p>
<pre><span>// Objective-C</span><br/><span>[csoundMotion enableAccelerometer];</span></pre>
<pre><span>// Swift</span><br/><span>csoundMotion.enableAccelerometer()</span></pre>
<p><strong>5.2 Gyroscope Binding</strong></p>
<p>The gyroscope binding, implemented in the CsoundGyroscopeBinding
class and enabled through the CsoundMotion class, allows access to
an iOS device’s gyroscope data along its three axes (X, Y, Z). The
accelerometer is a device that allows rotational velocity to be
determined, and together with the accelerometer forms a system with
six degrees of freedom. To enable it, use:</p>
<pre><span>// Objective-C</span><br/><span>[csoundMotion enableGyroscope];</span></pre>
<pre><span>// Swift</span><br/><span>csoundMotion.enableGyroscope()</span> </pre>
<p><strong>5.3 Attitude Binding</strong></p>
<p>Finally, the attitude binding, implemented in
CsoundAttitudeBinding and enabled through CsoundMotion, allows
access to an iOS device’s ’attitude data’. As the Apple reference
notes, ’attitude’ refers to the orientation of a body relative to a
given frame of reference. CsoundMotion enables this as three Euler
angle valies: ’roll’, ’pitch’, and ’yaw’ (rotation around X, Y, and
Z respectively). To enable the attitude binding, use:</p>
<pre><span>// Objective-C</span><br/><span>[csoundMotion enableAttitude];</span></pre>
<pre><span>// Swift</span><br/><span>csoundMotion.enableAttitude()</span></pre>
<p>Together, these bindings enable control of Csound parameters
with device motion in ways that are very simple and
straightforward. In the following subsection, an example
demonstrating each of the pre-set channel names as well as how some
of this information might be used is provided.</p>
<p><strong>5.4 Motion Csound Example</strong></p>
<p>Here is an example of a Csound instrument that accesses all of
the data, and demonstrates uses for some of it. This example is
taken from the Csound for iOS Examples project.</p>
<pre><span>instr 1</span><br/><span>kaccelX chnget " accelerometerX "</span><br/><span>kaccelY chnget " accelerometerY "</span><br/><span>kaccelZ chnget " accelerometerZ "</span></pre>
<pre><span>kgyroX chnget " gyroX "</span><br/><span>kgyroY chnget " gyroY "</span><br/><span>kgyroZ chnget " gyroZ "</span></pre>
<pre><span>kattRoll chnget " attitudeRoll "</span><br/><span>kattPitch chnget " attitudePitch "</span><br/><span>kattYaw chnget " attitudeYaw "</span></pre>
<pre><span>kcutoff = 5000 + (4000 * kattYaw )</span><br/><span>kresonance = .3 + (.3 * kattRoll )</span><br/><span>kpch = 880 + ( kaccelX * 220)</span><br/><span>a1 vco2 ( kattPitch + .5) * .2 , kpch</span><br/><span>a1 moogladder a1 , kcutoff , kresonance</span><br/><span>aL , aR reverbsc a1 , a1 , .72 , 5000</span><br/><span>outs aL , aR</span><br/><span>endin</span></pre>
<p>Each of the channel names is shown here, and each corresponds to
what is automatically set in the relevant binding. A little
experimenting can be very helpful in determining what to use these
values for in your particular application, and of course one is
never under any obligation to use all of them. Regardless, they can
be helpful and very straightforward ways to add now-familiar
interactions.</p>
<h3><strong>6 The CsoundBinding Protocol</strong></h3>
<p>The CsoundBinding protocol allows you to read values from and
write values to Csound using named channels that can be referenced
in your .csd file using opcodes like chnget and chnset, as
described in the earlier section on CsoundUI. The protocol
definition from CsoundObj is:</p>
<pre><span>@protocol CsoundBinding &lt;NSObject&gt;</span><br/><span>- (void)setup:(CsoundObj*)csoundObj;</span><br/><span>@optional</span><br/><span>- (void)cleanup;</span><br/><span>- (void)updateValuesFromCsound;</span><br/><span>- (void)updateValuesToCsound;</span><br/><span>@end</span></pre>
<p>In order to add a binding object to Csound, use CsoundObj’s
addBinding method:</p>
<pre><span>// Objective-C</span><br/><span>[self.csound addBinding:self];</span></pre>
<pre><span>// Swift</span><br/><span>csound.addBinding(self)</span> </pre>
<p>Note that you will need to conform to the CsoundBinding
protocol, and implement. at minimum, the required setup method. The
CsoundBinding setup method will be called on every object added as
a binding, and the remaining methods, marked with the @optional
directive will be called on any bindings that implement them.</p>
<p><strong>6.1 Channels and Channel Types</strong></p>
<p>Named channels allow us to pass data to and from Csound while it
is running. These channels refer to memory locations that we can
write to and Csound can read from, and vice-versa. The two most
common channel types are: <span>CSOUND_CONTROL_CHANNEL</span>
refers to a floating point control channel, normally associated
with a k-rate variable in
Csound. <span>CSOUND_AUDIO_CHANNEL</span> refers to an array
of floating point audio samples of length ksmps.</p>
<p>Each of these can be an input or output channel depending on
whether values are being passed to or from Csound.</p>
<p>Given below is an example of using named channels in a
simplified Csound instrument. The polymorphic chnget and chnset
opcodes are used, and the context here implies that kverb received
its value from an input control channel named "verbMix", and that
asig outputs to an audio channel named "samples".</p>
<pre><span>giSqr ftgen 2 , 0 , 8192 , 10 , 1 , 0 , .33 , 0 , .2 , 0 , .14 , </span><span>0 , .11 , 0 , .09</span></pre>
<pre><span>instr 1</span><br/><span>kfreq = p4</span><br/><span>kverb chnget " verbMix "</span><br/><span>aosc poscil .5 , kfreq , 2</span><br/><span>arvb reverb aosc , 1.5</span><br/><span>asig = (aosc * (1 - kverb) ) + (arvb * kverb)</span><br/><span>chnset asig , " samples "</span><br/><span>outs asig , asig</span><br/><span>endin</span></pre>
<p>The section that follows will describe how to set up and pass
values to and from this instrument’s channels in an iOS
application.</p>
<h3><strong>6.2 The Setup Method</strong></h3>
<p>The setup method is called before Csound’s first performance
pass, and this is typically where channel references are created.
For example:</p>
<pre><span>// Objective-C</span><br/><span>// verbPtr and samplesPtr are instance variables of type float*</span></pre>
<pre><span>-(void)setup:(CsoundObj *)csoundObj {</span><br/><span>    verbPtr = [csoundObj getInputChannelPtr:@"verbMix" </span><span>channelType:CSOUND_CONTROL_CHANNEL];</span><br/><span>    samplesPtr = [csoundObj getOutputChannelPtr:@"samples" </span><span>channelType:CSOUND_AUDIO_CHANNEL];</span><br/><span>}</span></pre>
<pre><span>// Swift</span><br/><span>var verbPtr: UnsafeMutablePointer&lt;Float&gt;?</span><br/><span>var samplesPtr: UnsafeMutablePointer&lt;Float&gt;?</span></pre>
<pre><span>func setup(_ csoundObj: CsoundObj) {</span><br/><span>    verbPtr = csoundObj.getInputChannelPtr("verbMix", </span><span>channelType: CSOUND_CONTROL_CHANNEL)</span><br/><span>    samplesPtr = csoundObj.getOutputChannelPtr("samples", </span><span>channelType: CSOUND_AUDIO_CHANNEL)</span><br/><span>}</span></pre>
<p>The cleanup method from CsoundBinding, also optional, is
intended for use in removing bindings once they are no longer
active. This can be done using CsoundObj’s removeBinding
method:</p>
<pre><span>// Objective-C</span><br/><span>// verbPtr and samplesPtr are instance variables of type float*</span><br/><span>-(void)cleanup {</span><br/><span>    [self.csound removeBinding:self];</span><br/><span>}</span></pre>
<pre><span>// Swift</span><br/><span>func cleanup() {</span><br/><span>    csound.removeBinding(self)</span><br/><span>}</span></pre>
<h3><strong>6.3 Communicating Values To and From
Csound</strong></h3>
<p>Communicating values to Csound is normally handled in the
updateValuesToCsound method. This method is called once per
performance pass (i.e. at the k-rate). For example:</p>
<pre><span>// Objective-C</span><br/><span>-(void)updateValuesToCsound {</span><br/><span>    *verbPtr = self.verbSlider.value;</span><br/><span>}</span></pre>
<pre><span>// Swift</span><br/><span>func updateValuesToCsound() {</span><br/><span>    verbPtr?.pointee = verbSlider.value</span><br/><span>}</span></pre>
<p>This updates the value at a memory location that Csound has
already associated with a named channel (in the setup method). This
process has essentially replicated the functionality of the
CsoundUI API’s slider binding. The advantage here is that we could
perform any transformation on the slider value, or associate
another value (that might not be associated with a UI object) with
the channel altogether. To pass values back from Csound, we use the
updateValuesFromCsound method.</p>
<pre><span>// Objective-C</span><br/><span>-(void)updateValuesFromCsound {</span><br/><span>    float *samps = samplesPtr;</span><br/><span>}</span></pre>
<p>Note that in Swift, we have do a little extra work in order to
get an array of samples that we can easily index into:</p>
<pre><span>// Swift</span><br/><span>func updateValuesFromCsound() {</span><br/><span>    let samps = samplesPtr?.pointee</span><br/><span>    let sampsArray = [Float](UnsafeBufferPointer(start: audioPtr,</span><br/><span>    count: Int(csound.getKsmps())))</span><br/><span>}</span></pre>
<p>Note also that updateValuesToCsound is called before
updateValuesFromCsound during each performance pass, with the
Csound engine performance call in between the two.</p>
<h3><strong>7 The CsoundObjListener Protocol</strong></h3>
<p>The CsoundObjListener protocol allows objects in your program to
be notified when Csound begins running, and when it completes
running. The protocol definition from CsoundObj is:</p>
<pre><span>@protocol CsoundObjListener &lt;NSObject&gt;</span><br/><span>@optional</span><br/><span>- (void)csoundObjStarted:(CsoundObj *)csoundObj;</span><br/><span>- (void)csoundObjCompleted:(CsoundObj *)csoundObj;</span><br/><span>@end</span> </pre>
<p>Note that there are no methods that an object is required to
adopt in order to conform to this protocol. These methods simply
allow an object to elect to be notified when Csound either begins,
completes running, or both. Note that these methods are not called
on the main thread, so any UI work must be explicitly run on the
main thread. For example:</p>
<pre><span>// Objective-C</span><br/><span>-(void)viewDidLoad {</span><br/><span>    [super viewDidLoad];</span><br/><span>    [self.csound addListener:self];</span><br/><span>}</span><br/><span>- (void)csoundObjStarted:(CsoundObj *)csoundObj {</span><br/><span>    [self.runningLabel performSelectorOnMainThread:@selector(setText:) </span><span>withObject:@"Csound Running" </span><span>waitUntilDone:NO];</span><br/><span>}</span></pre>
<pre><span>// Swift</span><br/><span>override func viewDidLoad() {</span><br/><span>    super.viewDidLoad()</span><br/><span>    csound.add(self)</span><br/><span>}</span><br/><span>func csoundObjCompleted(_ csoundObj: CsoundObj) {</span><br/><span>    DispatchQueue.main.async { [unowned self] in</span><br/><span>        self.runningLabel.text = "Csound Stopped"</span><br/><span>    }</span><br/><span>}</span></pre>
<h3><strong>8 Console Output</strong></h3>
<p>Console output from Csound is handled via a callback. You can
set the method that handles console info using CsoundObj’s
setMessageCallbackSelector method, and passing in an appropriate
selector, for instance:</p>
<pre><span>// Objective-C</span><br/><span>[self.csound setMessageCallbackSelector:@selector(printMessage:)];</span></pre>
<pre><span>// Swift</span><br/><span>csound.setMessageCallbackSelector(#selector(printMessage(_:)))</span></pre>
<p>An object of type NSValue will be passed in. This object is
acting as a wrapper for a C struct of type Message. The definition
for Message in CsoundObj.h is:</p>
<pre><span>typedef struct {</span><br/><span>    CSOUND *cs;</span><br/><span>    int attr;</span><br/><span>    const char *format;</span><br/><span>    va_list valist;</span><br/><span>} Message;</span> </pre>
<p>The two fields of interest to us for the purposes of console
output are format and valist. The former is a format string, and
the latter represents a list of arguments to match its format
specifiers.</p>
<p>The process demonstrated in the code examples below can be
described as:</p>
<ol>
<li>Declare an instance of a Message struct.</li>
<li>Unwrap the NSValue to store its contained Message value at the
address of this instance.</li>
<li>Declare an empty C string, to act as a buffer.</li>
<li>Use the vsnprintf function to populate the buffer with the
formatted output string.</li>
<li>Wrap this C string in an Objective-C NSString or Swift
String.</li>
</ol>
<pre><span>// Objective-C</span><br/><span>- (void)printMessage:(NSValue *)infoObj</span><br/><span>    Message info;</span><br/><span>    [infoObj getValue:&amp;info];</span><br/><span>    char message[1024];</span><br/><span>    vsnprintf(message, 1024, info.format, info.valist);</span><br/><span>    NSString *messageStr = [NSString stringWithFormat:@"%s", message];</span><br/><span>    NSLog(@"%@", messageStr);</span><br/><span>}</span></pre>
<p>Note that in Swift, we have to create a CVaListPointer
(equivalent to a va_list* in C) for use with the vsnprintf()
function:</p>
<pre><span>// Swift</span><br/><span>func messageCallback(_ infoObj: NSValue) {</span><br/><span>    var info = Message()</span><br/><span>    infoObj.getValue(&amp;info)</span><br/><span>    let message = UnsafeMutablePointer&lt;Int8&gt;.allocate(capacity: 1024)</span><br/><span>    let va_ptr: CVaListPointer = CVaListPointer(_fromUnsafeMutablePointer: </span><span>&amp;(info.valist))</span><br/><span>    vsnprintf(message, 1024, info.format, va_ptr)</span><br/><span>    let messageStr = String(cString: message)</span><br/><span>    print(messageStr)</span><br/><span>}</span></pre>
<p>In both cases above, we are printing the resulting string
objects to Xcode’s console. This can be very useful for finding and
addressing issues that have to do with Csound or with a .csd file
you might be using.</p>
<p>We could also pass the resulting string object around in our
program; for example, we could insert the contents of this string
object into a UITextView for a simulated Csound console output.</p>
<h3><strong>9 Csound-iOS and MIDI</strong></h3>
<p><strong>9.1 CsoundObj and MIDI</strong></p>
<p>The Csound iOS API provides two possible ways of passing MIDI
information to Csound. CsoundObj can receive MIDI events from
CoreMIDI directly. By default, this functionality is disabled, but
setting CsoundObj’s midiInEnabled property to true (or YES on
Objective-C) enables it. This must, however be done before Csound
is run.</p>
<p>Note that you must also set the appropriate command-line flag in
your csd, under CsOptions. For example, -M0. Additionally, the MIDI
device must be connected before the application is started.</p>
<p><strong>9.2 MidiWidgetsManager</strong></p>
<p>The second way that is provided to communicate MIDI information
to Csound is indirect, via the use of UI widgets and CsoundUI. In
this case, the MidiWidgetsManager uses a MidiWidgetsWrapper to
connect a MIDI CC to a UI object, and then CsoundUI can be used to
connect this UI object’s value to a named channel in Csound. For
instance:</p>
<pre><span>// Objective-C</span><br/><span>MidiWidgetsManager *widgetsManager = [[MidiWidgetsManager alloc] init];</span><br/><span>[widgetsManager addSlider:self.cutoffSlider forControllerNumber:5];</span><br/><span>[csoundUI addSlider:self.cutoffSlider forChannelName:@"cutoff"];</span><br/><span>[widgetsManager openMidiIn];</span></pre>
<pre><span>// Swift</span><br/><span>let widgetsManager = MidiWidgetsManager()</span><br/><span>widgetsManager.add(cutoffSlider, forControllerNumber: 5)</span><br/><span>csoundUI?.add(cutoffSlider, forChannelName: "cutoff")</span><br/><span>widgetsManager.openMidiIn()</span></pre>
<p>An advantage of this variant is that MIDI connections to the UI
widgets are active even when Csound is not running, so visual
feedback can still be provided, for example. At the time of
writing, support is only built-in for UISliders.</p>
<h3><strong>10 Other Functionality</strong></h3>
<p>This section describes a few methods of CsoundObj that are
potentially helpful for more complex applications.</p>
<p><strong>10.1 getCsound</strong></p>
<pre><span>(CSOUND *)getCsound;</span></pre>
<p>The getCsound method returns a pointer to a struct of type
CSOUND, the underlying Csound instance in the C API that the iOS
API wraps. Because the iOS API only wraps the most commonly needed
functionality from the Csound C API, this method can be helpful for
accessing it directly without needing to modify the Csound iOS API
to do so.</p>
<p>Note that this returns an opaque pointer because the declaration
of this struct type is not directly accessible. This should,
however, still allow you to pass it into Csound C API functions in
either Objective-C or Swift if you would like to access them.</p>
<p><strong>10.2 getAudioUnit</strong></p>
<pre><span>(AudioUnit *)getAudioUnit;</span></pre>
<p>The getAudioUnit method returns a pointer to a CsoundObj
instance’s I/O AudioUnit, which provides audio input and output to
Csound from iOS.</p>
<p>This can have several potential purposes. As a simple example,
you can use the <span>AudioOutputUnitStop()</span> function
with the returned value’s pointee to pause rendering, and
<span>AudioOutputUnitStart()</span> to resume.</p>
<p><strong>10.3 updateOrchestra</strong></p>
<pre><span>(void)updateOrchestra:(NSString *)orchestraString;</span></pre>
<p>The updateOrchestra method allows you to supply a new Csound
orchestra as a string.</p>
<p><strong>10.4 Other</strong></p>
<p>Additionally, getKsmps returns the current ksmps value, and
getNumChannels returns the number of audio channels in use by the
current Csound instance. These both act directly as wrappers to
Csound C API functions.</p>
<h3><strong>11 Example Projects</strong></h3>
<p>The Csound iOS examples project, available in both Objective-C
and Swift, is a collection of code that demonstrates common uses of
and interactions with the Csound iOS API.</p>
<p>For documentation on the examples, refer to the Csound-iOS
reference manual (Yi, Lazzarini, Boulanger), included with the API
and examples.</p>
<p><strong>11.1 csoundSynthesizer</strong></p>
<p>csoundSynthesizer is a separate project that demonstrates
building a small, simple iOS application that is usable as a
rudimentary synthesizer. It is not intended to be an exhaustive
reference, for which purpose the Csound iOS Examples projects are
better suited, but to help a new user get up and running with
Csound on iOS. The project is available in both Swift and
Objective-C <a href="https://github.com/nikhilsinghmus/csoundSynthesizer">here.</a></p>
<h3><strong>12 Conclusion</strong></h3>
<p>This guide provides an outline of the Csound iOS API’s
functionality, and demonstrates some common applications of it, in
order to aid those who have acquired even some background in Csound
to develop powerful audio applications without worrying about the
low-level intricacies of Apple’s Core Audio.</p>
<p>We wish you all the best as you continue your journey into
developing apps with the power and possibilities Csound has to
offer.</p>
</body>
</html>
